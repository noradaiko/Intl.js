{"version":3,"file":"Intl.js","sources":["../src/util.js","../src/exp.js","../src/6.locales-currencies-tz.js","../src/9.negotiation.js","../src/8.intl.js","../src/11.numberformat.js","../src/cldr.js","../src/12.datetimeformat.js","../src/13.locale-sensitive-functions.js","../src/core.js","../src/main.js"],"sourcesContent":["const realDefineProp = (function () {\n        let sentinel = {};\n        try {\n            Object.defineProperty(sentinel, 'a', {});\n            return 'a' in sentinel;\n        } catch (e) {\n            return false;\n        }\n    })();\n\n// Need a workaround for getters in ES3\nexport const es3 = !realDefineProp && !Object.prototype.__defineGetter__;\n\n// We use this a lot (and need it for proto-less objects)\nexport const hop = Object.prototype.hasOwnProperty;\n\n// Naive defineProperty for compatibility\nexport const defineProperty = realDefineProp ? Object.defineProperty : function (obj, name, desc) {\n    if ('get' in desc && obj.__defineGetter__)\n        obj.__defineGetter__(name, desc.get);\n\n    else if (!hop.call(obj, name) || 'value' in desc)\n        obj[name] = desc.value;\n};\n\n// Array.prototype.indexOf, as good as we need it to be\nexport const arrIndexOf = Array.prototype.indexOf || function (search) {\n    /*jshint validthis:true */\n    let t = this;\n    if (!t.length)\n        return -1;\n\n    for (let i = arguments[1] || 0, max = t.length; i < max; i++) {\n        if (t[i] === search)\n            return i;\n    }\n\n    return -1;\n};\n\n// Create an object with the specified prototype (2nd arg required for Record)\nexport const objCreate = Object.create || function (proto, props) {\n    let obj;\n\n    function F() {}\n    F.prototype = proto;\n    obj = new F();\n\n    for (let k in props) {\n        if (hop.call(props, k))\n            defineProperty(obj, k, props[k]);\n    }\n\n    return obj;\n};\n\n// Snapshot some (hopefully still) native built-ins\nexport const arrSlice  = Array.prototype.slice;\nexport const arrConcat = Array.prototype.concat;\nexport const arrPush   = Array.prototype.push;\nexport const arrJoin   = Array.prototype.join;\nexport const arrShift  = Array.prototype.shift;\n\n// Naive Function.prototype.bind for compatibility\nexport const fnBind = Function.prototype.bind || function (thisObj) {\n    let fn = this,\n        args = arrSlice.call(arguments, 1);\n\n    // All our (presently) bound functions have either 1 or 0 arguments. By returning\n    // different function signatures, we can pass some tests in ES3 environments\n    if (fn.length === 1) {\n        return function () {\n            return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n        };\n    }\n    return function () {\n        return fn.apply(thisObj, arrConcat.call(args, arrSlice.call(arguments)));\n    };\n};\n\n// Object housing internal properties for constructors\nexport const internals = objCreate(null);\n\n// Keep internal properties internal\nexport const secret = Math.random();\n\n// Helper functions\n// ================\n\n/**\n * A function to deal with the inaccuracy of calculating log10 in pre-ES6\n * JavaScript environments. Math.log(num) / Math.LN10 was responsible for\n * causing issue #62.\n */\nexport function log10Floor (n) {\n    // ES6 provides the more accurate Math.log10\n    if (typeof Math.log10 === 'function')\n        return Math.floor(Math.log10(n));\n\n    let x = Math.round(Math.log(n) * Math.LOG10E);\n    return x - (Number('1e' + x) > n);\n}\n\n/**\n * A map that doesn't contain Object in its prototype chain\n */\nexport function Record (obj) {\n    // Copy only own properties over unless this object is already a Record instance\n    for (let k in obj) {\n        if (obj instanceof Record || hop.call(obj, k))\n            defineProperty(this, k, { value: obj[k], enumerable: true, writable: true, configurable: true });\n    }\n}\nRecord.prototype = objCreate(null);\n\n/**\n * An ordered list\n */\nexport function List() {\n    defineProperty(this, 'length', { writable:true, value: 0 });\n\n    if (arguments.length)\n        arrPush.apply(this, arrSlice.call(arguments));\n}\nList.prototype = objCreate(null);\n\n/**\n * Constructs a regular expression to restore tainted RegExp properties\n */\nexport function createRegExpRestore () {\n    let esc = /[.?*+^$[\\]\\\\(){}|-]/g,\n        lm  = RegExp.lastMatch || '',\n        ml  = RegExp.multiline ? 'm' : '',\n        ret = { input: RegExp.input },\n        reg = new List(),\n        has = false,\n        cap = {};\n\n    // Create a snapshot of all the 'captured' properties\n    for (let i = 1; i <= 9; i++)\n        has = (cap['$'+i] = RegExp['$'+i]) || has;\n\n    // Now we've snapshotted some properties, escape the lastMatch string\n    lm = lm.replace(esc, '\\\\$&');\n\n    // If any of the captured strings were non-empty, iterate over them all\n    if (has) {\n        for (let i = 1; i <= 9; i++) {\n            let m = cap['$'+i];\n\n            // If it's empty, add an empty capturing group\n            if (!m)\n                lm = '()' + lm;\n\n            // Else find the string in lm and escape & wrap it to capture it\n            else {\n                m = m.replace(esc, '\\\\$&');\n                lm = lm.replace(m, '(' + m + ')');\n            }\n\n            // Push it to the reg and chop lm to make sure further groups come after\n            arrPush.call(reg, lm.slice(0, lm.indexOf('(') + 1));\n            lm = lm.slice(lm.indexOf('(') + 1);\n        }\n    }\n\n    // Create the regular expression that will reconstruct the RegExp properties\n    ret.exp = new RegExp(arrJoin.call(reg, '') + lm, ml);\n\n    return ret;\n}\n\n/**\n * Mimics ES5's abstract ToObject() function\n */\nexport function toObject (arg) {\n    if (arg === null)\n        throw new TypeError('Cannot convert null or undefined to object');\n\n    return Object(arg);\n}\n\n/**\n * Returns \"internal\" properties for an object\n */\nexport function getInternalProperties (obj) {\n    if (hop.call(obj, '__getInternalProperties'))\n        return obj.__getInternalProperties(secret);\n\n    return objCreate(null);\n}\n","/**\n* Defines regular expressions for various operations related to the BCP 47 syntax,\n* as defined at http://tools.ietf.org/html/bcp47#section-2.1\n*/\n\n// extlang       = 3ALPHA              ; selected ISO 639 codes\n//                 *2(\"-\" 3ALPHA)      ; permanently reserved\nconst extlang = '[a-z]{3}(?:-[a-z]{3}){0,2}';\n\n// language      = 2*3ALPHA            ; shortest ISO 639 code\n//                 [\"-\" extlang]       ; sometimes followed by\n//                                     ; extended language subtags\n//               / 4ALPHA              ; or reserved for future use\n//               / 5*8ALPHA            ; or registered language subtag\nconst language = '(?:[a-z]{2,3}(?:-' + extlang + ')?|[a-z]{4}|[a-z]{5,8})';\n\n// script        = 4ALPHA              ; ISO 15924 code\nconst script = '[a-z]{4}';\n\n// region        = 2ALPHA              ; ISO 3166-1 code\n//               / 3DIGIT              ; UN M.49 code\nconst region = '(?:[a-z]{2}|\\\\d{3})';\n\n// variant       = 5*8alphanum         ; registered variants\n//               / (DIGIT 3alphanum)\nconst variant = '(?:[a-z0-9]{5,8}|\\\\d[a-z0-9]{3})';\n\n//                                     ; Single alphanumerics\n//                                     ; \"x\" reserved for private use\n// singleton     = DIGIT               ; 0 - 9\n//               / %x41-57             ; A - W\n//               / %x59-5A             ; Y - Z\n//               / %x61-77             ; a - w\n//               / %x79-7A             ; y - z\nconst singleton = '[0-9a-wy-z]';\n\n// extension     = singleton 1*(\"-\" (2*8alphanum))\nconst extension = singleton + '(?:-[a-z0-9]{2,8})+';\n\n// privateuse    = \"x\" 1*(\"-\" (1*8alphanum))\nconst privateuse = 'x(?:-[a-z0-9]{1,8})+';\n\n// irregular     = \"en-GB-oed\"         ; irregular tags do not match\n//               / \"i-ami\"             ; the 'langtag' production and\n//               / \"i-bnn\"             ; would not otherwise be\n//               / \"i-default\"         ; considered 'well-formed'\n//               / \"i-enochian\"        ; These tags are all valid,\n//               / \"i-hak\"             ; but most are deprecated\n//               / \"i-klingon\"         ; in favor of more modern\n//               / \"i-lux\"             ; subtags or subtag\n//               / \"i-mingo\"           ; combination\n//               / \"i-navajo\"\n//               / \"i-pwn\"\n//               / \"i-tao\"\n//               / \"i-tay\"\n//               / \"i-tsu\"\n//               / \"sgn-BE-FR\"\n//               / \"sgn-BE-NL\"\n//               / \"sgn-CH-DE\"\nconst irregular = '(?:en-GB-oed'\n          + '|i-(?:ami|bnn|default|enochian|hak|klingon|lux|mingo|navajo|pwn|tao|tay|tsu)'\n          + '|sgn-(?:BE-FR|BE-NL|CH-DE))';\n\n// regular       = \"art-lojban\"        ; these tags match the 'langtag'\n//               / \"cel-gaulish\"       ; production, but their subtags\n//               / \"no-bok\"            ; are not extended language\n//               / \"no-nyn\"            ; or variant subtags: their meaning\n//               / \"zh-guoyu\"          ; is defined by their registration\n//               / \"zh-hakka\"          ; and all of these are deprecated\n//               / \"zh-min\"            ; in favor of a more modern\n//               / \"zh-min-nan\"        ; subtag or sequence of subtags\n//               / \"zh-xiang\"\nconst regular = '(?:art-lojban|cel-gaulish|no-bok|no-nyn'\n        + '|zh-(?:guoyu|hakka|min|min-nan|xiang))';\n\n// grandfathered = irregular           ; non-redundant tags registered\n//               / regular             ; during the RFC 3066 era\nconst grandfathered = '(?:' + irregular + '|' + regular + ')';\n\n// langtag       = language\n//                 [\"-\" script]\n//                 [\"-\" region]\n//                 *(\"-\" variant)\n//                 *(\"-\" extension)\n//                 [\"-\" privateuse]\nconst langtag = language + '(?:-' + script + ')?(?:-' + region + ')?(?:-'\n        + variant + ')*(?:-' + extension + ')*(?:-' + privateuse + ')?';\n\n// Language-Tag  = langtag             ; normal language tags\n//               / privateuse          ; private use tag\n//               / grandfathered       ; grandfathered tags\nexport let expBCP47Syntax = RegExp('^(?:'+langtag+'|'+privateuse+'|'+grandfathered+')$', 'i');\n\n// Match duplicate variants in a language tag\nexport let expVariantDupes = RegExp('^(?!x).*?-('+variant+')-(?:\\\\w{4,8}-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match duplicate singletons in a language tag (except in private use)\nexport let expSingletonDupes = RegExp('^(?!x).*?-('+singleton+')-(?:\\\\w+-(?!x-))*\\\\1\\\\b', 'i');\n\n// Match all extension sequences\nexport let expExtSequences = RegExp('-'+extension, 'ig');\n","// Sect 6.2 Language Tags\n// ======================\n\nimport {\n    expBCP47Syntax,\n    expExtSequences,\n    expVariantDupes,\n    expSingletonDupes,\n} from './exp';\n\nimport {\n    hop,\n    arrJoin,\n    arrSlice,\n} from \"./util.js\";\n\n// Default locale is the first-added locale data for us\nexport let defaultLocale;\nexport function setDefaultLocale(locale) {\n    defaultLocale = locale;\n}\n\n// IANA Subtag Registry redundant tag and subtag maps\nconst redundantTags = {\n    tags: {\n        \"art-lojban\": \"jbo\",\n        \"i-ami\": \"ami\",\n        \"i-bnn\": \"bnn\",\n        \"i-hak\": \"hak\",\n        \"i-klingon\": \"tlh\",\n        \"i-lux\": \"lb\",\n        \"i-navajo\": \"nv\",\n        \"i-pwn\": \"pwn\",\n        \"i-tao\": \"tao\",\n        \"i-tay\": \"tay\",\n        \"i-tsu\": \"tsu\",\n        \"no-bok\": \"nb\",\n        \"no-nyn\": \"nn\",\n        \"sgn-BE-FR\": \"sfb\",\n        \"sgn-BE-NL\": \"vgt\",\n        \"sgn-CH-DE\": \"sgg\",\n        \"zh-guoyu\": \"cmn\",\n        \"zh-hakka\": \"hak\",\n        \"zh-min-nan\": \"nan\",\n        \"zh-xiang\": \"hsn\",\n        \"sgn-BR\": \"bzs\",\n        \"sgn-CO\": \"csn\",\n        \"sgn-DE\": \"gsg\",\n        \"sgn-DK\": \"dsl\",\n        \"sgn-ES\": \"ssp\",\n        \"sgn-FR\": \"fsl\",\n        \"sgn-GB\": \"bfi\",\n        \"sgn-GR\": \"gss\",\n        \"sgn-IE\": \"isg\",\n        \"sgn-IT\": \"ise\",\n        \"sgn-JP\": \"jsl\",\n        \"sgn-MX\": \"mfs\",\n        \"sgn-NI\": \"ncs\",\n        \"sgn-NL\": \"dse\",\n        \"sgn-NO\": \"nsl\",\n        \"sgn-PT\": \"psr\",\n        \"sgn-SE\": \"swl\",\n        \"sgn-US\": \"ase\",\n        \"sgn-ZA\": \"sfs\",\n        \"zh-cmn\": \"cmn\",\n        \"zh-cmn-Hans\": \"cmn-Hans\",\n        \"zh-cmn-Hant\": \"cmn-Hant\",\n        \"zh-gan\": \"gan\",\n        \"zh-wuu\": \"wuu\",\n        \"zh-yue\": \"yue\",\n    },\n    subtags: {\n        BU: \"MM\",\n        DD: \"DE\",\n        FX: \"FR\",\n        TP: \"TL\",\n        YD: \"YE\",\n        ZR: \"CD\",\n        heploc: \"alalc97\",\n        'in': \"id\",\n        iw: \"he\",\n        ji: \"yi\",\n        jw: \"jv\",\n        mo: \"ro\",\n        ayx: \"nun\",\n        bjd: \"drl\",\n        ccq: \"rki\",\n        cjr: \"mom\",\n        cka: \"cmr\",\n        cmk: \"xch\",\n        drh: \"khk\",\n        drw: \"prs\",\n        gav: \"dev\",\n        hrr: \"jal\",\n        ibi: \"opa\",\n        kgh: \"kml\",\n        lcq: \"ppr\",\n        mst: \"mry\",\n        myt: \"mry\",\n        sca: \"hle\",\n        tie: \"ras\",\n        tkk: \"twm\",\n        tlw: \"weo\",\n        tnf: \"prs\",\n        ybd: \"rki\",\n        yma: \"lrr\",\n    },\n    extLang: {\n        aao: [\"aao\", \"ar\"],\n        abh: [\"abh\", \"ar\"],\n        abv: [\"abv\", \"ar\"],\n        acm: [\"acm\", \"ar\"],\n        acq: [\"acq\", \"ar\"],\n        acw: [\"acw\", \"ar\"],\n        acx: [\"acx\", \"ar\"],\n        acy: [\"acy\", \"ar\"],\n        adf: [\"adf\", \"ar\"],\n        ads: [\"ads\", \"sgn\"],\n        aeb: [\"aeb\", \"ar\"],\n        aec: [\"aec\", \"ar\"],\n        aed: [\"aed\", \"sgn\"],\n        aen: [\"aen\", \"sgn\"],\n        afb: [\"afb\", \"ar\"],\n        afg: [\"afg\", \"sgn\"],\n        ajp: [\"ajp\", \"ar\"],\n        apc: [\"apc\", \"ar\"],\n        apd: [\"apd\", \"ar\"],\n        arb: [\"arb\", \"ar\"],\n        arq: [\"arq\", \"ar\"],\n        ars: [\"ars\", \"ar\"],\n        ary: [\"ary\", \"ar\"],\n        arz: [\"arz\", \"ar\"],\n        ase: [\"ase\", \"sgn\"],\n        asf: [\"asf\", \"sgn\"],\n        asp: [\"asp\", \"sgn\"],\n        asq: [\"asq\", \"sgn\"],\n        asw: [\"asw\", \"sgn\"],\n        auz: [\"auz\", \"ar\"],\n        avl: [\"avl\", \"ar\"],\n        ayh: [\"ayh\", \"ar\"],\n        ayl: [\"ayl\", \"ar\"],\n        ayn: [\"ayn\", \"ar\"],\n        ayp: [\"ayp\", \"ar\"],\n        bbz: [\"bbz\", \"ar\"],\n        bfi: [\"bfi\", \"sgn\"],\n        bfk: [\"bfk\", \"sgn\"],\n        bjn: [\"bjn\", \"ms\"],\n        bog: [\"bog\", \"sgn\"],\n        bqn: [\"bqn\", \"sgn\"],\n        bqy: [\"bqy\", \"sgn\"],\n        btj: [\"btj\", \"ms\"],\n        bve: [\"bve\", \"ms\"],\n        bvl: [\"bvl\", \"sgn\"],\n        bvu: [\"bvu\", \"ms\"],\n        bzs: [\"bzs\", \"sgn\"],\n        cdo: [\"cdo\", \"zh\"],\n        cds: [\"cds\", \"sgn\"],\n        cjy: [\"cjy\", \"zh\"],\n        cmn: [\"cmn\", \"zh\"],\n        coa: [\"coa\", \"ms\"],\n        cpx: [\"cpx\", \"zh\"],\n        csc: [\"csc\", \"sgn\"],\n        csd: [\"csd\", \"sgn\"],\n        cse: [\"cse\", \"sgn\"],\n        csf: [\"csf\", \"sgn\"],\n        csg: [\"csg\", \"sgn\"],\n        csl: [\"csl\", \"sgn\"],\n        csn: [\"csn\", \"sgn\"],\n        csq: [\"csq\", \"sgn\"],\n        csr: [\"csr\", \"sgn\"],\n        czh: [\"czh\", \"zh\"],\n        czo: [\"czo\", \"zh\"],\n        doq: [\"doq\", \"sgn\"],\n        dse: [\"dse\", \"sgn\"],\n        dsl: [\"dsl\", \"sgn\"],\n        dup: [\"dup\", \"ms\"],\n        ecs: [\"ecs\", \"sgn\"],\n        esl: [\"esl\", \"sgn\"],\n        esn: [\"esn\", \"sgn\"],\n        eso: [\"eso\", \"sgn\"],\n        eth: [\"eth\", \"sgn\"],\n        fcs: [\"fcs\", \"sgn\"],\n        fse: [\"fse\", \"sgn\"],\n        fsl: [\"fsl\", \"sgn\"],\n        fss: [\"fss\", \"sgn\"],\n        gan: [\"gan\", \"zh\"],\n        gds: [\"gds\", \"sgn\"],\n        gom: [\"gom\", \"kok\"],\n        gse: [\"gse\", \"sgn\"],\n        gsg: [\"gsg\", \"sgn\"],\n        gsm: [\"gsm\", \"sgn\"],\n        gss: [\"gss\", \"sgn\"],\n        gus: [\"gus\", \"sgn\"],\n        hab: [\"hab\", \"sgn\"],\n        haf: [\"haf\", \"sgn\"],\n        hak: [\"hak\", \"zh\"],\n        hds: [\"hds\", \"sgn\"],\n        hji: [\"hji\", \"ms\"],\n        hks: [\"hks\", \"sgn\"],\n        hos: [\"hos\", \"sgn\"],\n        hps: [\"hps\", \"sgn\"],\n        hsh: [\"hsh\", \"sgn\"],\n        hsl: [\"hsl\", \"sgn\"],\n        hsn: [\"hsn\", \"zh\"],\n        icl: [\"icl\", \"sgn\"],\n        ils: [\"ils\", \"sgn\"],\n        inl: [\"inl\", \"sgn\"],\n        ins: [\"ins\", \"sgn\"],\n        ise: [\"ise\", \"sgn\"],\n        isg: [\"isg\", \"sgn\"],\n        isr: [\"isr\", \"sgn\"],\n        jak: [\"jak\", \"ms\"],\n        jax: [\"jax\", \"ms\"],\n        jcs: [\"jcs\", \"sgn\"],\n        jhs: [\"jhs\", \"sgn\"],\n        jls: [\"jls\", \"sgn\"],\n        jos: [\"jos\", \"sgn\"],\n        jsl: [\"jsl\", \"sgn\"],\n        jus: [\"jus\", \"sgn\"],\n        kgi: [\"kgi\", \"sgn\"],\n        knn: [\"knn\", \"kok\"],\n        kvb: [\"kvb\", \"ms\"],\n        kvk: [\"kvk\", \"sgn\"],\n        kvr: [\"kvr\", \"ms\"],\n        kxd: [\"kxd\", \"ms\"],\n        lbs: [\"lbs\", \"sgn\"],\n        lce: [\"lce\", \"ms\"],\n        lcf: [\"lcf\", \"ms\"],\n        liw: [\"liw\", \"ms\"],\n        lls: [\"lls\", \"sgn\"],\n        lsg: [\"lsg\", \"sgn\"],\n        lsl: [\"lsl\", \"sgn\"],\n        lso: [\"lso\", \"sgn\"],\n        lsp: [\"lsp\", \"sgn\"],\n        lst: [\"lst\", \"sgn\"],\n        lsy: [\"lsy\", \"sgn\"],\n        ltg: [\"ltg\", \"lv\"],\n        lvs: [\"lvs\", \"lv\"],\n        lzh: [\"lzh\", \"zh\"],\n        max: [\"max\", \"ms\"],\n        mdl: [\"mdl\", \"sgn\"],\n        meo: [\"meo\", \"ms\"],\n        mfa: [\"mfa\", \"ms\"],\n        mfb: [\"mfb\", \"ms\"],\n        mfs: [\"mfs\", \"sgn\"],\n        min: [\"min\", \"ms\"],\n        mnp: [\"mnp\", \"zh\"],\n        mqg: [\"mqg\", \"ms\"],\n        mre: [\"mre\", \"sgn\"],\n        msd: [\"msd\", \"sgn\"],\n        msi: [\"msi\", \"ms\"],\n        msr: [\"msr\", \"sgn\"],\n        mui: [\"mui\", \"ms\"],\n        mzc: [\"mzc\", \"sgn\"],\n        mzg: [\"mzg\", \"sgn\"],\n        mzy: [\"mzy\", \"sgn\"],\n        nan: [\"nan\", \"zh\"],\n        nbs: [\"nbs\", \"sgn\"],\n        ncs: [\"ncs\", \"sgn\"],\n        nsi: [\"nsi\", \"sgn\"],\n        nsl: [\"nsl\", \"sgn\"],\n        nsp: [\"nsp\", \"sgn\"],\n        nsr: [\"nsr\", \"sgn\"],\n        nzs: [\"nzs\", \"sgn\"],\n        okl: [\"okl\", \"sgn\"],\n        orn: [\"orn\", \"ms\"],\n        ors: [\"ors\", \"ms\"],\n        pel: [\"pel\", \"ms\"],\n        pga: [\"pga\", \"ar\"],\n        pks: [\"pks\", \"sgn\"],\n        prl: [\"prl\", \"sgn\"],\n        prz: [\"prz\", \"sgn\"],\n        psc: [\"psc\", \"sgn\"],\n        psd: [\"psd\", \"sgn\"],\n        pse: [\"pse\", \"ms\"],\n        psg: [\"psg\", \"sgn\"],\n        psl: [\"psl\", \"sgn\"],\n        pso: [\"pso\", \"sgn\"],\n        psp: [\"psp\", \"sgn\"],\n        psr: [\"psr\", \"sgn\"],\n        pys: [\"pys\", \"sgn\"],\n        rms: [\"rms\", \"sgn\"],\n        rsi: [\"rsi\", \"sgn\"],\n        rsl: [\"rsl\", \"sgn\"],\n        sdl: [\"sdl\", \"sgn\"],\n        sfb: [\"sfb\", \"sgn\"],\n        sfs: [\"sfs\", \"sgn\"],\n        sgg: [\"sgg\", \"sgn\"],\n        sgx: [\"sgx\", \"sgn\"],\n        shu: [\"shu\", \"ar\"],\n        slf: [\"slf\", \"sgn\"],\n        sls: [\"sls\", \"sgn\"],\n        sqk: [\"sqk\", \"sgn\"],\n        sqs: [\"sqs\", \"sgn\"],\n        ssh: [\"ssh\", \"ar\"],\n        ssp: [\"ssp\", \"sgn\"],\n        ssr: [\"ssr\", \"sgn\"],\n        svk: [\"svk\", \"sgn\"],\n        swc: [\"swc\", \"sw\"],\n        swh: [\"swh\", \"sw\"],\n        swl: [\"swl\", \"sgn\"],\n        syy: [\"syy\", \"sgn\"],\n        tmw: [\"tmw\", \"ms\"],\n        tse: [\"tse\", \"sgn\"],\n        tsm: [\"tsm\", \"sgn\"],\n        tsq: [\"tsq\", \"sgn\"],\n        tss: [\"tss\", \"sgn\"],\n        tsy: [\"tsy\", \"sgn\"],\n        tza: [\"tza\", \"sgn\"],\n        ugn: [\"ugn\", \"sgn\"],\n        ugy: [\"ugy\", \"sgn\"],\n        ukl: [\"ukl\", \"sgn\"],\n        uks: [\"uks\", \"sgn\"],\n        urk: [\"urk\", \"ms\"],\n        uzn: [\"uzn\", \"uz\"],\n        uzs: [\"uzs\", \"uz\"],\n        vgt: [\"vgt\", \"sgn\"],\n        vkk: [\"vkk\", \"ms\"],\n        vkt: [\"vkt\", \"ms\"],\n        vsi: [\"vsi\", \"sgn\"],\n        vsl: [\"vsl\", \"sgn\"],\n        vsv: [\"vsv\", \"sgn\"],\n        wuu: [\"wuu\", \"zh\"],\n        xki: [\"xki\", \"sgn\"],\n        xml: [\"xml\", \"sgn\"],\n        xmm: [\"xmm\", \"ms\"],\n        xms: [\"xms\", \"sgn\"],\n        yds: [\"yds\", \"sgn\"],\n        ysl: [\"ysl\", \"sgn\"],\n        yue: [\"yue\", \"zh\"],\n        zib: [\"zib\", \"sgn\"],\n        zlm: [\"zlm\", \"ms\"],\n        zmi: [\"zmi\", \"ms\"],\n        zsl: [\"zsl\", \"sgn\"],\n        zsm: [\"zsm\", \"ms\"],\n    },\n};\n\n/**\n * Convert only a-z to uppercase as per section 6.1 of the spec\n */\nexport function toLatinUpperCase (str) {\n    let i = str.length;\n\n    while (i--) {\n        let ch = str.charAt(i);\n\n        if (ch >= \"a\" && ch <= \"z\")\n            str = str.slice(0, i) + ch.toUpperCase() + str.slice(i+1);\n    }\n\n    return str;\n}\n\n/**\n * The IsStructurallyValidLanguageTag abstract operation verifies that the locale\n * argument (which must be a String value)\n *\n * - represents a well-formed BCP 47 language tag as specified in RFC 5646 section\n *   2.1, or successor,\n * - does not include duplicate variant subtags, and\n * - does not include duplicate singleton subtags.\n *\n * The abstract operation returns true if locale can be generated from the ABNF\n * grammar in section 2.1 of the RFC, starting with Language-Tag, and does not\n * contain duplicate variant or singleton subtags (other than as a private use\n * subtag). It returns false otherwise. Terminal value characters in the grammar are\n * interpreted as the Unicode equivalents of the ASCII octet values given.\n */\nexport function /* 6.2.2 */IsStructurallyValidLanguageTag(locale) {\n    // represents a well-formed BCP 47 language tag as specified in RFC 5646\n    if (!expBCP47Syntax.test(locale))\n        return false;\n\n    // does not include duplicate variant subtags, and\n    if (expVariantDupes.test(locale))\n        return false;\n\n    // does not include duplicate singleton subtags.\n    if (expSingletonDupes.test(locale))\n        return false;\n\n    return true;\n}\n\n/**\n * The CanonicalizeLanguageTag abstract operation returns the canonical and case-\n * regularized form of the locale argument (which must be a String value that is\n * a structurally valid BCP 47 language tag as verified by the\n * IsStructurallyValidLanguageTag abstract operation). It takes the steps\n * specified in RFC 5646 section 4.5, or successor, to bring the language tag\n * into canonical form, and to regularize the case of the subtags, but does not\n * take the steps to bring a language tag into “extlang form” and to reorder\n * variant subtags.\n\n * The specifications for extensions to BCP 47 language tags, such as RFC 6067,\n * may include canonicalization rules for the extension subtag sequences they\n * define that go beyond the canonicalization rules of RFC 5646 section 4.5.\n * Implementations are allowed, but not required, to apply these additional rules.\n */\nexport function /* 6.2.3 */CanonicalizeLanguageTag (locale) {\n    let match, parts;\n\n    // A language tag is in 'canonical form' when the tag is well-formed\n    // according to the rules in Sections 2.1 and 2.2\n\n    // Section 2.1 says all subtags use lowercase...\n    locale = locale.toLowerCase();\n\n    // ...with 2 exceptions: 'two-letter and four-letter subtags that neither\n    // appear at the start of the tag nor occur after singletons.  Such two-letter\n    // subtags are all uppercase (as in the tags \"en-CA-x-ca\" or \"sgn-BE-FR\") and\n    // four-letter subtags are titlecase (as in the tag \"az-Latn-x-latn\").\n    parts = locale.split('-');\n    for (let i = 1, max = parts.length; i < max; i++) {\n        // Two-letter subtags are all uppercase\n        if (parts[i].length === 2)\n            parts[i] = parts[i].toUpperCase();\n\n        // Four-letter subtags are titlecase\n        else if (parts[i].length === 4)\n            parts[i] = parts[i].charAt(0).toUpperCase() + parts[i].slice(1);\n\n        // Is it a singleton?\n        else if (parts[i].length === 1 && parts[i] !== 'x')\n            break;\n    }\n    locale = arrJoin.call(parts, '-');\n\n    // The steps laid out in RFC 5646 section 4.5 are as follows:\n\n    // 1.  Extension sequences are ordered into case-insensitive ASCII order\n    //     by singleton subtag.\n    if ((match = locale.match(expExtSequences)) && match.length > 1) {\n        // The built-in sort() sorts by ASCII order, so use that\n        match.sort();\n\n        // Replace all extensions with the joined, sorted array\n        locale = locale.replace(\n            RegExp('(?:' + expExtSequences.source + ')+', 'i'),\n            arrJoin.call(match, '')\n        );\n    }\n\n    // 2.  Redundant or grandfathered tags are replaced by their 'Preferred-\n    //     Value', if there is one.\n    if (hop.call(redundantTags.tags, locale))\n        locale = redundantTags.tags[locale];\n\n    // 3.  Subtags are replaced by their 'Preferred-Value', if there is one.\n    //     For extlangs, the original primary language subtag is also\n    //     replaced if there is a primary language subtag in the 'Preferred-\n    //     Value'.\n    parts = locale.split('-');\n\n    for (let i = 1, max = parts.length; i < max; i++) {\n        if (hop.call(redundantTags.subtags, parts[i]))\n            parts[i] = redundantTags.subtags[parts[i]];\n\n        else if (hop.call(redundantTags.extLang, parts[i])) {\n            parts[i] = redundantTags.extLang[parts[i]][0];\n\n            // For extlang tags, the prefix needs to be removed if it is redundant\n            if (i === 1 && redundantTags.extLang[parts[1]][1] === parts[0]) {\n                parts = arrSlice.call(parts, i++);\n                max -= 1;\n            }\n        }\n    }\n\n    return arrJoin.call(parts, '-');\n}\n\n/**\n * The DefaultLocale abstract operation returns a String value representing the\n * structurally valid (6.2.2) and canonicalized (6.2.3) BCP 47 language tag for the\n * host environment’s current locale.\n */\nexport function /* 6.2.4 */DefaultLocale () {\n    return defaultLocale;\n}\n\n// Sect 6.3 Currency Codes\n// =======================\n\nconst expCurrencyCode = /^[A-Z]{3}$/;\n\n/**\n * The IsWellFormedCurrencyCode abstract operation verifies that the currency argument\n * (after conversion to a String value) represents a well-formed 3-letter ISO currency\n * code. The following steps are taken:\n */\nexport function /* 6.3.1 */IsWellFormedCurrencyCode(currency) {\n    // 1. Let `c` be ToString(currency)\n    let c = String(currency);\n\n    // 2. Let `normalized` be the result of mapping c to upper case as described\n    //    in 6.1.\n    let normalized = toLatinUpperCase(c);\n\n    // 3. If the string length of normalized is not 3, return false.\n    // 4. If normalized contains any character that is not in the range \"A\" to \"Z\"\n    //    (U+0041 to U+005A), return false.\n    if (expCurrencyCode.test(normalized) === false)\n        return false;\n\n    // 5. Return true\n    return true;\n}\n","// Sect 9.2 Abstract Operations\n// ============================\n\nimport {\n    List,\n    toObject,\n    arrIndexOf,\n    arrPush,\n    arrSlice,\n    Record,\n    hop,\n    defineProperty,\n} from \"./util.js\";\n\nimport {\n    IsStructurallyValidLanguageTag,\n    CanonicalizeLanguageTag,\n    DefaultLocale,\n} from \"./6.locales-currencies-tz.js\";\n\nconst expUnicodeExSeq = /-u(?:-[0-9a-z]{2,8})+/gi; // See `extension` below\n\nexport function /* 9.2.1 */CanonicalizeLocaleList (locales) {\n// The abstract operation CanonicalizeLocaleList takes the following steps:\n\n    // 1. If locales is undefined, then a. Return a new empty List\n    if (locales === undefined)\n        return new List();\n\n    // 2. Let seen be a new empty List.\n    let seen = new List();\n\n    // 3. If locales is a String value, then\n    //    a. Let locales be a new array created as if by the expression new\n    //    Array(locales) where Array is the standard built-in constructor with\n    //    that name and locales is the value of locales.\n    locales = typeof locales === 'string' ? [ locales ] : locales;\n\n    // 4. Let O be ToObject(locales).\n    let O = toObject(locales);\n\n    // 5. Let lenValue be the result of calling the [[Get]] internal method of\n    //    O with the argument \"length\".\n    // 6. Let len be ToUint32(lenValue).\n    let len = O.length;\n\n    // 7. Let k be 0.\n    let k = 0;\n\n    // 8. Repeat, while k < len\n    while (k < len) {\n        // a. Let Pk be ToString(k).\n        let Pk = String(k);\n\n        // b. Let kPresent be the result of calling the [[HasProperty]] internal\n        //    method of O with argument Pk.\n        let kPresent = Pk in O;\n\n        // c. If kPresent is true, then\n        if (kPresent) {\n            // i. Let kValue be the result of calling the [[Get]] internal\n            //     method of O with argument Pk.\n            let kValue = O[Pk];\n\n            // ii. If the type of kValue is not String or Object, then throw a\n            //     TypeError exception.\n            if (kValue === null || (typeof kValue !== 'string' && typeof kValue !== 'object'))\n                throw new TypeError('String or Object type expected');\n\n            // iii. Let tag be ToString(kValue).\n            let tag = String(kValue);\n\n            // iv. If the result of calling the abstract operation\n            //     IsStructurallyValidLanguageTag (defined in 6.2.2), passing tag as\n            //     the argument, is false, then throw a RangeError exception.\n            if (!IsStructurallyValidLanguageTag(tag))\n                throw new RangeError(\"'\" + tag + \"' is not a structurally valid language tag\");\n\n            // v. Let tag be the result of calling the abstract operation\n            //    CanonicalizeLanguageTag (defined in 6.2.3), passing tag as the\n            //    argument.\n            tag = CanonicalizeLanguageTag(tag);\n\n            // vi. If tag is not an element of seen, then append tag as the last\n            //     element of seen.\n            if (arrIndexOf.call(seen, tag) === -1)\n                arrPush.call(seen, tag);\n        }\n\n        // d. Increase k by 1.\n        k++;\n    }\n\n    // 9. Return seen.\n    return seen;\n}\n\n/**\n * The BestAvailableLocale abstract operation compares the provided argument\n * locale, which must be a String value with a structurally valid and\n * canonicalized BCP 47 language tag, against the locales in availableLocales and\n * returns either the longest non-empty prefix of locale that is an element of\n * availableLocales, or undefined if there is no such element. It uses the\n * fallback mechanism of RFC 4647, section 3.4. The following steps are taken:\n */\nexport function /* 9.2.2 */BestAvailableLocale (availableLocales, locale) {\n    // 1. Let candidate be locale\n    let candidate = locale;\n\n    // 2. Repeat\n    while (candidate) {\n        // a. If availableLocales contains an element equal to candidate, then return\n        // candidate.\n        if (arrIndexOf.call(availableLocales, candidate) > -1)\n            return candidate;\n\n        // b. Let pos be the character index of the last occurrence of \"-\"\n        // (U+002D) within candidate. If that character does not occur, return\n        // undefined.\n        let pos = candidate.lastIndexOf('-');\n\n        if (pos < 0)\n            return;\n\n        // c. If pos ≥ 2 and the character \"-\" occurs at index pos-2 of candidate,\n        //    then decrease pos by 2.\n        if (pos >= 2 && candidate.charAt(pos - 2) === '-')\n            pos -= 2;\n\n        // d. Let candidate be the substring of candidate from position 0, inclusive,\n        //    to position pos, exclusive.\n        candidate = candidate.substring(0, pos);\n    }\n}\n\n/**\n * The LookupMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The following steps are taken:\n */\nexport function /* 9.2.3 */LookupMatcher (availableLocales, requestedLocales) {\n    // 1. Let i be 0.\n    let i = 0;\n\n    // 2. Let len be the number of elements in requestedLocales.\n    let len = requestedLocales.length;\n\n    // 3. Let availableLocale be undefined.\n    let availableLocale;\n\n    let locale, noExtensionsLocale;\n\n    // 4. Repeat while i < len and availableLocale is undefined:\n    while (i < len && !availableLocale) {\n        // a. Let locale be the element of requestedLocales at 0-origined list\n        //    position i.\n        locale = requestedLocales[i];\n\n        // b. Let noExtensionsLocale be the String value that is locale with all\n        //    Unicode locale extension sequences removed.\n        noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n\n        // c. Let availableLocale be the result of calling the\n        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n        //    arguments availableLocales and noExtensionsLocale.\n        availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. Increase i by 1.\n        i++;\n    }\n\n    // 5. Let result be a new Record.\n    let result = new Record();\n\n    // 6. If availableLocale is not undefined, then\n    if (availableLocale !== undefined) {\n        // a. Set result.[[locale]] to availableLocale.\n        result['[[locale]]'] = availableLocale;\n\n        // b. If locale and noExtensionsLocale are not the same String value, then\n        if (String(locale) !== String(noExtensionsLocale)) {\n            // i. Let extension be the String value consisting of the first\n            //    substring of locale that is a Unicode locale extension sequence.\n            let extension = locale.match(expUnicodeExSeq)[0];\n\n            // ii. Let extensionIndex be the character position of the initial\n            //     \"-\" of the first Unicode locale extension sequence within locale.\n            let extensionIndex = locale.indexOf('-u-');\n\n            // iii. Set result.[[extension]] to extension.\n            result['[[extension]]'] = extension;\n\n            // iv. Set result.[[extensionIndex]] to extensionIndex.\n            result['[[extensionIndex]]'] = extensionIndex;\n        }\n    }\n    // 7. Else\n    else\n        // a. Set result.[[locale]] to the value returned by the DefaultLocale abstract\n        //    operation (defined in 6.2.4).\n        result['[[locale]]'] = DefaultLocale();\n\n    // 8. Return result\n    return result;\n}\n\n/**\n * The BestFitMatcher abstract operation compares requestedLocales, which must be\n * a List as returned by CanonicalizeLocaleList, against the locales in\n * availableLocales and determines the best available language to meet the\n * request. The algorithm is implementation dependent, but should produce results\n * that a typical user of the requested locales would perceive as at least as\n * good as those produced by the LookupMatcher abstract operation. Options\n * specified through Unicode locale extension sequences must be ignored by the\n * algorithm. Information about such subsequences is returned separately.\n * The abstract operation returns a record with a [[locale]] field, whose value\n * is the language tag of the selected locale, which must be an element of\n * availableLocales. If the language tag of the request locale that led to the\n * selected locale contained a Unicode locale extension sequence, then the\n * returned record also contains an [[extension]] field whose value is the first\n * Unicode locale extension sequence, and an [[extensionIndex]] field whose value\n * is the index of the first Unicode locale extension sequence within the request\n * locale language tag.\n */\nexport function /* 9.2.4 */BestFitMatcher (availableLocales, requestedLocales) {\n    return LookupMatcher(availableLocales, requestedLocales);\n}\n\n/**\n * The ResolveLocale abstract operation compares a BCP 47 language priority list\n * requestedLocales against the locales in availableLocales and determines the\n * best available language to meet the request. availableLocales and\n * requestedLocales must be provided as List values, options as a Record.\n */\nexport function /* 9.2.5 */ResolveLocale (availableLocales, requestedLocales, options, relevantExtensionKeys, localeData) {\n    if (availableLocales.length === 0) {\n        throw new ReferenceError('No locale data has been provided for this object yet.');\n    }\n\n    // The following steps are taken:\n    // 1. Let matcher be the value of options.[[localeMatcher]].\n    let matcher = options['[[localeMatcher]]'];\n\n    let r;\n\n    // 2. If matcher is \"lookup\", then\n    if (matcher === 'lookup')\n        // a. Let r be the result of calling the LookupMatcher abstract operation\n        //    (defined in 9.2.3) with arguments availableLocales and\n        //    requestedLocales.\n        r = LookupMatcher(availableLocales, requestedLocales);\n\n    // 3. Else\n    else\n        // a. Let r be the result of calling the BestFitMatcher abstract\n        //    operation (defined in 9.2.4) with arguments availableLocales and\n        //    requestedLocales.\n        r = BestFitMatcher(availableLocales, requestedLocales);\n\n    // 4. Let foundLocale be the value of r.[[locale]].\n    let foundLocale = r['[[locale]]'];\n\n    let extensionSubtags, extensionSubtagsLength;\n\n    // 5. If r has an [[extension]] field, then\n    if (hop.call(r, '[[extension]]')) {\n        // a. Let extension be the value of r.[[extension]].\n        let extension = r['[[extension]]'];\n        // b. Let split be the standard built-in function object defined in ES5,\n        //    15.5.4.14.\n        let split = String.prototype.split;\n        // c. Let extensionSubtags be the result of calling the [[Call]] internal\n        //    method of split with extension as the this value and an argument\n        //    list containing the single item \"-\".\n        extensionSubtags = split.call(extension, '-');\n        // d. Let extensionSubtagsLength be the result of calling the [[Get]]\n        //    internal method of extensionSubtags with argument \"length\".\n        extensionSubtagsLength = extensionSubtags.length;\n    }\n\n    // 6. Let result be a new Record.\n    let result = new Record();\n\n    // 7. Set result.[[dataLocale]] to foundLocale.\n    result['[[dataLocale]]'] = foundLocale;\n\n    // 8. Let supportedExtension be \"-u\".\n    let supportedExtension = '-u';\n    // 9. Let i be 0.\n    let i = 0;\n    // 10. Let len be the result of calling the [[Get]] internal method of\n    //     relevantExtensionKeys with argument \"length\".\n    let len = relevantExtensionKeys.length;\n\n    // 11 Repeat while i < len:\n    while (i < len) {\n        // a. Let key be the result of calling the [[Get]] internal method of\n        //    relevantExtensionKeys with argument ToString(i).\n        let key = relevantExtensionKeys[i];\n        // b. Let foundLocaleData be the result of calling the [[Get]] internal\n        //    method of localeData with the argument foundLocale.\n        let foundLocaleData = localeData[foundLocale];\n        // c. Let keyLocaleData be the result of calling the [[Get]] internal\n        //    method of foundLocaleData with the argument key.\n        let keyLocaleData = foundLocaleData[key];\n        // d. Let value be the result of calling the [[Get]] internal method of\n        //    keyLocaleData with argument \"0\".\n        let value = keyLocaleData['0'];\n        // e. Let supportedExtensionAddition be \"\".\n        let supportedExtensionAddition = '';\n        // f. Let indexOf be the standard built-in function object defined in\n        //    ES5, 15.4.4.14.\n        let indexOf = arrIndexOf;\n\n        // g. If extensionSubtags is not undefined, then\n        if (extensionSubtags !== undefined) {\n            // i. Let keyPos be the result of calling the [[Call]] internal\n            //    method of indexOf with extensionSubtags as the this value and\n            // an argument list containing the single item key.\n            let keyPos = indexOf.call(extensionSubtags, key);\n\n            // ii. If keyPos ≠ -1, then\n            if (keyPos !== -1) {\n                // 1. If keyPos + 1 < extensionSubtagsLength and the length of the\n                //    result of calling the [[Get]] internal method of\n                //    extensionSubtags with argument ToString(keyPos +1) is greater\n                //    than 2, then\n                if (keyPos + 1 < extensionSubtagsLength\n                        && extensionSubtags[keyPos + 1].length > 2) {\n                    // a. Let requestedValue be the result of calling the [[Get]]\n                    //    internal method of extensionSubtags with argument\n                    //    ToString(keyPos + 1).\n                    let requestedValue = extensionSubtags[keyPos + 1];\n                    // b. Let valuePos be the result of calling the [[Call]]\n                    //    internal method of indexOf with keyLocaleData as the\n                    //    this value and an argument list containing the single\n                    //    item requestedValue.\n                    let valuePos = indexOf.call(keyLocaleData, requestedValue);\n\n                    // c. If valuePos ≠ -1, then\n                    if (valuePos !== -1) {\n                        // i. Let value be requestedValue.\n                        value = requestedValue,\n                        // ii. Let supportedExtensionAddition be the\n                        //     concatenation of \"-\", key, \"-\", and value.\n                        supportedExtensionAddition = '-' + key + '-' + value;\n                    }\n                }\n                // 2. Else\n                else {\n                    // a. Let valuePos be the result of calling the [[Call]]\n                    // internal method of indexOf with keyLocaleData as the this\n                    // value and an argument list containing the single item\n                    // \"true\".\n                    let valuePos = indexOf(keyLocaleData, 'true');\n\n                    // b. If valuePos ≠ -1, then\n                    if (valuePos !== -1)\n                        // i. Let value be \"true\".\n                        value = 'true';\n                }\n            }\n        }\n        // h. If options has a field [[<key>]], then\n        if (hop.call(options, '[[' + key + ']]')) {\n            // i. Let optionsValue be the value of options.[[<key>]].\n            let optionsValue = options['[[' + key + ']]'];\n\n            // ii. If the result of calling the [[Call]] internal method of indexOf\n            //     with keyLocaleData as the this value and an argument list\n            //     containing the single item optionsValue is not -1, then\n            if (indexOf.call(keyLocaleData, optionsValue) !== -1) {\n                // 1. If optionsValue is not equal to value, then\n                if (optionsValue !== value) {\n                    // a. Let value be optionsValue.\n                    value = optionsValue;\n                    // b. Let supportedExtensionAddition be \"\".\n                    supportedExtensionAddition = '';\n                }\n            }\n        }\n        // i. Set result.[[<key>]] to value.\n        result['[[' + key + ']]'] = value;\n\n        // j. Append supportedExtensionAddition to supportedExtension.\n        supportedExtension += supportedExtensionAddition;\n\n        // k. Increase i by 1.\n        i++;\n    }\n    // 12. If the length of supportedExtension is greater than 2, then\n    if (supportedExtension.length > 2) {\n        // a.\n        let privateIndex = foundLocale.indexOf(\"-x-\");\n        // b.\n        if (privateIndex === -1) {\n            // i.\n            foundLocale = foundLocale + supportedExtension;\n        }\n        // c.\n        else {\n            // i.\n            let preExtension = foundLocale.substring(0, privateIndex);\n            // ii.\n            let postExtension = foundLocale.substring(privateIndex);\n            // iii.\n            foundLocale = preExtension + supportedExtension + postExtension;\n        }\n        // d. asserting - skipping\n        // e.\n        foundLocale = CanonicalizeLanguageTag(foundLocale);\n    }\n    // 13. Set result.[[locale]] to foundLocale.\n    result['[[locale]]'] = foundLocale;\n\n    // 14. Return result.\n    return result;\n}\n\n/**\n * The LookupSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the BCP 47 Lookup algorithm.\n * Locales appear in the same order in the returned list as in requestedLocales.\n * The following steps are taken:\n */\nexport function /* 9.2.6 */LookupSupportedLocales (availableLocales, requestedLocales) {\n    // 1. Let len be the number of elements in requestedLocales.\n    let len = requestedLocales.length;\n    // 2. Let subset be a new empty List.\n    let subset = new List();\n    // 3. Let k be 0.\n    let k = 0;\n\n    // 4. Repeat while k < len\n    while (k < len) {\n        // a. Let locale be the element of requestedLocales at 0-origined list\n        //    position k.\n        let locale = requestedLocales[k];\n        // b. Let noExtensionsLocale be the String value that is locale with all\n        //    Unicode locale extension sequences removed.\n        let noExtensionsLocale = String(locale).replace(expUnicodeExSeq, '');\n        // c. Let availableLocale be the result of calling the\n        //    BestAvailableLocale abstract operation (defined in 9.2.2) with\n        //    arguments availableLocales and noExtensionsLocale.\n        let availableLocale = BestAvailableLocale(availableLocales, noExtensionsLocale);\n\n        // d. If availableLocale is not undefined, then append locale to the end of\n        //    subset.\n        if (availableLocale !== undefined)\n            arrPush.call(subset, locale);\n\n        // e. Increment k by 1.\n        k++;\n    }\n\n    // 5. Let subsetArray be a new Array object whose elements are the same\n    //    values in the same order as the elements of subset.\n    let subsetArray = arrSlice.call(subset);\n\n    // 6. Return subsetArray.\n    return subsetArray;\n}\n\n/**\n * The BestFitSupportedLocales abstract operation returns the subset of the\n * provided BCP 47 language priority list requestedLocales for which\n * availableLocales has a matching locale when using the Best Fit Matcher\n * algorithm. Locales appear in the same order in the returned list as in\n * requestedLocales. The steps taken are implementation dependent.\n */\nexport function /*9.2.7 */BestFitSupportedLocales (availableLocales, requestedLocales) {\n    // ###TODO: implement this function as described by the specification###\n    return LookupSupportedLocales(availableLocales, requestedLocales);\n}\n\n/**\n * The SupportedLocales abstract operation returns the subset of the provided BCP\n * 47 language priority list requestedLocales for which availableLocales has a\n * matching locale. Two algorithms are available to match the locales: the Lookup\n * algorithm described in RFC 4647 section 3.4, and an implementation dependent\n * best-fit algorithm. Locales appear in the same order in the returned list as\n * in requestedLocales. The following steps are taken:\n */\nexport function /*9.2.8 */SupportedLocales (availableLocales, requestedLocales, options) {\n    let matcher, subset;\n\n    // 1. If options is not undefined, then\n    if (options !== undefined) {\n        // a. Let options be ToObject(options).\n        options = new Record(toObject(options));\n        // b. Let matcher be the result of calling the [[Get]] internal method of\n        //    options with argument \"localeMatcher\".\n        matcher = options.localeMatcher;\n\n        // c. If matcher is not undefined, then\n        if (matcher !== undefined) {\n            // i. Let matcher be ToString(matcher).\n            matcher = String(matcher);\n\n            // ii. If matcher is not \"lookup\" or \"best fit\", then throw a RangeError\n            //     exception.\n            if (matcher !== 'lookup' && matcher !== 'best fit')\n                throw new RangeError('matcher should be \"lookup\" or \"best fit\"');\n        }\n    }\n    // 2. If matcher is undefined or \"best fit\", then\n    if (matcher === undefined || matcher === 'best fit')\n        // a. Let subset be the result of calling the BestFitSupportedLocales\n        //    abstract operation (defined in 9.2.7) with arguments\n        //    availableLocales and requestedLocales.\n        subset = BestFitSupportedLocales(availableLocales, requestedLocales);\n    // 3. Else\n    else\n        // a. Let subset be the result of calling the LookupSupportedLocales\n        //    abstract operation (defined in 9.2.6) with arguments\n        //    availableLocales and requestedLocales.\n        subset = LookupSupportedLocales(availableLocales, requestedLocales);\n\n    // 4. For each named own property name P of subset,\n    for (let P in subset) {\n        if (!hop.call(subset, P))\n            continue;\n\n        // a. Let desc be the result of calling the [[GetOwnProperty]] internal\n        //    method of subset with P.\n        // b. Set desc.[[Writable]] to false.\n        // c. Set desc.[[Configurable]] to false.\n        // d. Call the [[DefineOwnProperty]] internal method of subset with P, desc,\n        //    and true as arguments.\n        defineProperty(subset, P, {\n            writable: false, configurable: false, value: subset[P],\n        });\n    }\n    // \"Freeze\" the array so no new elements can be added\n    defineProperty(subset, 'length', { writable: false });\n\n    // 5. Return subset\n    return subset;\n}\n\n/**\n * The GetOption abstract operation extracts the value of the property named\n * property from the provided options object, converts it to the required type,\n * checks whether it is one of a List of allowed values, and fills in a fallback\n * value if necessary.\n */\nexport function /*9.2.9 */GetOption (options, property, type, values, fallback) {\n    // 1. Let value be the result of calling the [[Get]] internal method of\n    //    options with argument property.\n    let value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Assert: type is \"boolean\" or \"string\".\n        // b. If type is \"boolean\", then let value be ToBoolean(value).\n        // c. If type is \"string\", then let value be ToString(value).\n        value = type === 'boolean' ? Boolean(value)\n                  : (type === 'string' ? String(value) : value);\n\n        // d. If values is not undefined, then\n        if (values !== undefined) {\n            // i. If values does not contain an element equal to value, then throw a\n            //    RangeError exception.\n            if (arrIndexOf.call(values, value) === -1)\n                throw new RangeError(\"'\" + value + \"' is not an allowed value for `\" + property +'`');\n        }\n\n        // e. Return value.\n        return value;\n    }\n    // Else return fallback.\n    return fallback;\n}\n\n/**\n * The GetNumberOption abstract operation extracts a property value from the\n * provided options object, converts it to a Number value, checks whether it is\n * in the allowed range, and fills in a fallback value if necessary.\n */\nexport function /* 9.2.10 */GetNumberOption (options, property, minimum, maximum, fallback) {\n    // 1. Let value be the result of calling the [[Get]] internal method of\n    //    options with argument property.\n    let value = options[property];\n\n    // 2. If value is not undefined, then\n    if (value !== undefined) {\n        // a. Let value be ToNumber(value).\n        value = Number(value);\n\n        // b. If value is NaN or less than minimum or greater than maximum, throw a\n        //    RangeError exception.\n        if (isNaN(value) || value < minimum || value > maximum)\n            throw new RangeError('Value is not a number or outside accepted range');\n\n        // c. Return floor(value).\n        return Math.floor(value);\n    }\n    // 3. Else return fallback.\n    return fallback;\n}\n","import {\n    defineProperty,\n} from \"./util.js\";\n\nimport {\n  CanonicalizeLocaleList\n} from \"./9.negotiation.js\";\n\nexport const Intl = {};\n\nfunction GetCanonicalLocales (locales) {\n  let codes = CanonicalizeLocaleList(locales);\n  let result = [];\n  for (let code in codes) {\n    result.push(codes[code]);\n  }\n  return result;\n}\n\ndefineProperty(Intl, 'getCanonicalLocales', {\n    configurable: true,\n    value: GetCanonicalLocales,\n});\n","// 11.1 The Intl.NumberFormat constructor\n// ======================================\n\nimport {\n    IsWellFormedCurrencyCode,\n} from \"./6.locales-currencies-tz.js\";\n\nimport {\n    Intl,\n} from \"./8.intl.js\";\n\nimport {\n    CanonicalizeLocaleList,\n    SupportedLocales,\n    ResolveLocale,\n    GetNumberOption,\n    GetOption,\n} from \"./9.negotiation.js\";\n\nimport {\n    internals,\n    log10Floor,\n    List,\n    toObject,\n    arrPush,\n    arrJoin,\n    arrShift,\n    Record,\n    hop,\n    defineProperty,\n    es3,\n    fnBind,\n    getInternalProperties,\n    createRegExpRestore,\n    secret,\n    objCreate,\n} from \"./util.js\";\n\n// Currency minor units output from get-4217 grunt task, formatted\nconst currencyMinorUnits = {\n    BHD: 3, BYR: 0, XOF: 0, BIF: 0, XAF: 0, CLF: 4, CLP: 0, KMF: 0, DJF: 0,\n    XPF: 0, GNF: 0, ISK: 0, IQD: 3, JPY: 0, JOD: 3, KRW: 0, KWD: 3, LYD: 3,\n    OMR: 3, PYG: 0, RWF: 0, TND: 3, UGX: 0, UYI: 0, VUV: 0, VND: 0,\n};\n\n// Define the NumberFormat constructor internally so it cannot be tainted\nexport function NumberFormatConstructor () {\n    let locales = arguments[0];\n    let options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.NumberFormat(locales, options);\n    }\n\n    return InitializeNumberFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'NumberFormat', {\n    configurable: true,\n    writable: true,\n    value: NumberFormatConstructor,\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(Intl.NumberFormat, 'prototype', {\n    writable: false,\n});\n\n/**\n * The abstract operation InitializeNumberFormat accepts the arguments\n * numberFormat (which must be an object), locales, and options. It initializes\n * numberFormat as a NumberFormat object.\n */\nexport function /*11.1.1.1 */InitializeNumberFormat (numberFormat, locales, options) {\n    // This will be a internal properties object if we're not already initialized\n    let internal = getInternalProperties(numberFormat);\n\n    // Create an object whose props can be used to restore the values of RegExp props\n    let regexpState = createRegExpRestore();\n\n    // 1. If numberFormat has an [[initializedIntlObject]] internal property with\n    // value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true)\n        throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(numberFormat, '__getInternalProperties', {\n        value: function () {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret)\n                return internal;\n        },\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    let requestedLocales = CanonicalizeLocaleList(locales);\n\n    // 4. If options is undefined, then\n    if (options === undefined)\n        // a. Let options be the result of creating a new object as if by the\n        // expression new Object() where Object is the standard built-in constructor\n        // with that name.\n        options = {};\n\n    // 5. Else\n    else\n        // a. Let options be ToObject(options).\n        options = toObject(options);\n\n    // 6. Let opt be a new Record.\n    let opt = new Record(),\n\n    // 7. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with the arguments options, \"localeMatcher\", \"string\",\n    //    a List containing the two String values \"lookup\" and \"best fit\", and\n    //    \"best fit\".\n        matcher =  GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 8. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    // 9. Let NumberFormat be the standard built-in object that is the initial value\n    //    of Intl.NumberFormat.\n    // 10. Let localeData be the value of the [[localeData]] internal property of\n    //     NumberFormat.\n    let localeData = internals.NumberFormat['[[localeData]]'];\n\n    // 11. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //     NumberFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //     internal property of NumberFormat, and localeData.\n    let r = ResolveLocale(\n            internals.NumberFormat['[[availableLocales]]'], requestedLocales,\n            opt, internals.NumberFormat['[[relevantExtensionKeys]]'], localeData\n        );\n\n    // 12. Set the [[locale]] internal property of numberFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of numberFormat to the value\n    //     of r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n    let dataLocale = r['[[dataLocale]]'];\n\n    // 15. Let s be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"style\", \"string\", a List containing the three String\n    //     values \"decimal\", \"percent\", and \"currency\", and \"decimal\".\n    let s = GetOption(options, 'style', 'string', new List('decimal', 'percent', 'currency'), 'decimal');\n\n    // 16. Set the [[style]] internal property of numberFormat to s.\n    internal['[[style]]'] = s;\n\n    // 17. Let c be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currency\", \"string\", undefined, and undefined.\n    let c = GetOption(options, 'currency', 'string');\n\n    // 18. If c is not undefined and the result of calling the\n    //     IsWellFormedCurrencyCode abstract operation (defined in 6.3.1) with\n    //     argument c is false, then throw a RangeError exception.\n    if (c !== undefined && !IsWellFormedCurrencyCode(c))\n        throw new RangeError(\"'\" + c + \"' is not a valid currency code\");\n\n    // 19. If s is \"currency\" and c is undefined, throw a TypeError exception.\n    if (s === 'currency' && c === undefined)\n        throw new TypeError('Currency code is required when style is currency');\n\n    let cDigits;\n\n    // 20. If s is \"currency\", then\n    if (s === 'currency') {\n        // a. Let c be the result of converting c to upper case as specified in 6.1.\n        c = c.toUpperCase();\n\n        // b. Set the [[currency]] internal property of numberFormat to c.\n        internal['[[currency]]'] = c;\n\n        // c. Let cDigits be the result of calling the CurrencyDigits abstract\n        //    operation (defined below) with argument c.\n        cDigits = CurrencyDigits(c);\n    }\n\n    // 21. Let cd be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"currencyDisplay\", \"string\", a List containing the\n    //     three String values \"code\", \"symbol\", and \"name\", and \"symbol\".\n    let cd = GetOption(options, 'currencyDisplay', 'string', new List('code', 'symbol', 'name'), 'symbol');\n\n    // 22. If s is \"currency\", then set the [[currencyDisplay]] internal property of\n    //     numberFormat to cd.\n    if (s === 'currency')\n        internal['[[currencyDisplay]]'] = cd;\n\n    // 23. Let mnid be the result of calling the GetNumberOption abstract operation\n    //     (defined in 9.2.10) with arguments options, \"minimumIntegerDigits\", 1, 21,\n    //     and 1.\n    let mnid = GetNumberOption(options, 'minimumIntegerDigits', 1, 21, 1);\n\n    // 24. Set the [[minimumIntegerDigits]] internal property of numberFormat to mnid.\n    internal['[[minimumIntegerDigits]]'] = mnid;\n\n    // 25. If s is \"currency\", then let mnfdDefault be cDigits; else let mnfdDefault\n    //     be 0.\n    let mnfdDefault = s === 'currency' ? cDigits : 0;\n\n    // 26. Let mnfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"minimumFractionDigits\", 0, 20, and mnfdDefault.\n    let mnfd = GetNumberOption(options, 'minimumFractionDigits', 0, 20, mnfdDefault);\n\n    // 27. Set the [[minimumFractionDigits]] internal property of numberFormat to mnfd.\n    internal['[[minimumFractionDigits]]'] = mnfd;\n\n    // 28. If s is \"currency\", then let mxfdDefault be max(mnfd, cDigits); else if s\n    //     is \"percent\", then let mxfdDefault be max(mnfd, 0); else let mxfdDefault\n    //     be max(mnfd, 3).\n    let mxfdDefault = s === 'currency' ? Math.max(mnfd, cDigits)\n                    : (s === 'percent' ? Math.max(mnfd, 0) : Math.max(mnfd, 3));\n\n    // 29. Let mxfd be the result of calling the GetNumberOption abstract operation\n    //     with arguments options, \"maximumFractionDigits\", mnfd, 20, and mxfdDefault.\n    let mxfd = GetNumberOption(options, 'maximumFractionDigits', mnfd, 20, mxfdDefault);\n\n    // 30. Set the [[maximumFractionDigits]] internal property of numberFormat to mxfd.\n    internal['[[maximumFractionDigits]]'] = mxfd;\n\n    // 31. Let mnsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"minimumSignificantDigits\".\n    let mnsd = options.minimumSignificantDigits;\n\n    // 32. Let mxsd be the result of calling the [[Get]] internal method of options\n    //     with argument \"maximumSignificantDigits\".\n    let mxsd = options.maximumSignificantDigits;\n\n    // 33. If mnsd is not undefined or mxsd is not undefined, then:\n    if (mnsd !== undefined || mxsd !== undefined) {\n        // a. Let mnsd be the result of calling the GetNumberOption abstract\n        //    operation with arguments options, \"minimumSignificantDigits\", 1, 21,\n        //    and 1.\n        mnsd = GetNumberOption(options, 'minimumSignificantDigits', 1, 21, 1);\n\n        // b. Let mxsd be the result of calling the GetNumberOption abstract\n        //     operation with arguments options, \"maximumSignificantDigits\", mnsd,\n        //     21, and 21.\n        mxsd = GetNumberOption(options, 'maximumSignificantDigits', mnsd, 21, 21);\n\n        // c. Set the [[minimumSignificantDigits]] internal property of numberFormat\n        //    to mnsd, and the [[maximumSignificantDigits]] internal property of\n        //    numberFormat to mxsd.\n        internal['[[minimumSignificantDigits]]'] = mnsd;\n        internal['[[maximumSignificantDigits]]'] = mxsd;\n    }\n    // 34. Let g be the result of calling the GetOption abstract operation with the\n    //     arguments options, \"useGrouping\", \"boolean\", undefined, and true.\n    let g = GetOption(options, 'useGrouping', 'boolean', undefined, true);\n\n    // 35. Set the [[useGrouping]] internal property of numberFormat to g.\n    internal['[[useGrouping]]'] = g;\n\n    // 36. Let dataLocaleData be the result of calling the [[Get]] internal method of\n    //     localeData with argument dataLocale.\n    let dataLocaleData = localeData[dataLocale];\n\n    // 37. Let patterns be the result of calling the [[Get]] internal method of\n    //     dataLocaleData with argument \"patterns\".\n    let patterns = dataLocaleData.patterns;\n\n    // 38. Assert: patterns is an object (see 11.2.3)\n\n    // 39. Let stylePatterns be the result of calling the [[Get]] internal method of\n    //     patterns with argument s.\n    let stylePatterns = patterns[s];\n\n    // 40. Set the [[positivePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"positivePattern\".\n    internal['[[positivePattern]]'] = stylePatterns.positivePattern;\n\n    // 41. Set the [[negativePattern]] internal property of numberFormat to the\n    //     result of calling the [[Get]] internal method of stylePatterns with the\n    //     argument \"negativePattern\".\n    internal['[[negativePattern]]'] = stylePatterns.negativePattern;\n\n    // 42. Set the [[boundFormat]] internal property of numberFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 43. Set the [[initializedNumberFormat]] internal property of numberFormat to\n    //     true.\n    internal['[[initializedNumberFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3)\n        numberFormat.format = GetFormatNumber.call(numberFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return numberFormat;\n}\n\nfunction CurrencyDigits(currency) {\n    // When the CurrencyDigits abstract operation is called with an argument currency\n    // (which must be an upper case String value), the following steps are taken:\n\n    // 1. If the ISO 4217 currency and funds code list contains currency as an\n    // alphabetic code, then return the minor unit value corresponding to the\n    // currency from the list; else return 2.\n    return currencyMinorUnits[currency] !== undefined\n                ? currencyMinorUnits[currency]\n                : 2;\n}\n\n/* 11.2.3 */internals.NumberFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['nu'],\n    '[[localeData]]': {},\n};\n\n/**\n * When the supportedLocalesOf method of Intl.NumberFormat is called, the\n * following steps are taken:\n */\n/* 11.2.2 */\ndefineProperty(Intl.NumberFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(function (locales) {\n        // Bound functions only have the `this` value altered if being used as a constructor,\n        // this lets us imitate a native function that has no constructor\n        if (!hop.call(this, '[[availableLocales]]'))\n            throw new TypeError('supportedLocalesOf() is not a constructor');\n\n        // Create an object whose props can be used to restore the values of RegExp props\n        let regexpState = createRegExpRestore(),\n\n        // 1. If options is not provided, then let options be undefined.\n            options = arguments[1],\n\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n        //    property of the standard built-in object that is the initial value of\n        //    Intl.NumberFormat.\n\n            availableLocales = this['[[availableLocales]]'],\n\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n        //    abstract operation (defined in 9.2.1) with argument locales.\n            requestedLocales = CanonicalizeLocaleList(locales);\n\n        // Restore the RegExp properties\n        regexpState.exp.test(regexpState.input);\n\n        // 4. Return the result of calling the SupportedLocales abstract operation\n        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n        //    and options.\n        return SupportedLocales(availableLocales, requestedLocales, options);\n    }, internals.NumberFormat),\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * NumberFormat object.\n */\n/* 11.3.2 */defineProperty(Intl.NumberFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatNumber,\n});\n\nfunction GetFormatNumber() {\n        let internal = this !== null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]'])\n            throw new TypeError('`this` value for format() is not an initialized Intl.NumberFormat object.');\n\n        // The value of the [[Get]] attribute is a function that takes the following\n        // steps:\n\n        // 1. If the [[boundFormat]] internal property of this NumberFormat object\n        //    is undefined, then:\n        if (internal['[[boundFormat]]'] === undefined) {\n            // a. Let F be a Function object, with internal properties set as\n            //    specified for built-in functions in ES5, 15, or successor, and the\n            //    length property set to 1, that takes the argument value and\n            //    performs the following steps:\n            let F = function (value) {\n                // i. If value is not provided, then let value be undefined.\n                // ii. Let x be ToNumber(value).\n                // iii. Return the result of calling the FormatNumber abstract\n                //      operation (defined below) with arguments this and x.\n                return FormatNumber(this, /* x = */Number(value));\n            };\n\n            // b. Let bind be the standard built-in function object defined in ES5,\n            //    15.3.4.5.\n            // c. Let bf be the result of calling the [[Call]] internal method of\n            //    bind with F as the this value and an argument list containing\n            //    the single item this.\n            let bf = fnBind.call(F, this);\n\n            // d. Set the [[boundFormat]] internal property of this NumberFormat\n            //    object to bf.\n            internal['[[boundFormat]]'] = bf;\n        }\n        // Return the value of the [[boundFormat]] internal property of this\n        // NumberFormat object.\n        return internal['[[boundFormat]]'];\n    }\n\nIntl.NumberFormat.prototype.formatToParts = function(value) {\n  let internal = this !== null && typeof this === 'object' && getInternalProperties(this);\n  if (!internal || !internal['[[initializedNumberFormat]]'])\n      throw new TypeError('`this` value for formatToParts() is not an initialized Intl.NumberFormat object.');\n\n  let x = Number(value);\n  return FormatNumberToParts(this, x);\n};\n\nfunction FormatNumberToParts (numberFormat, x) {\n\n    // Create an object whose props can be used to restore the values of RegExp props\n    let regexpState = createRegExpRestore(),\n\n        internal = getInternalProperties(numberFormat),\n        locale = internal['[[dataLocale]]'],\n        nums   = internal['[[numberingSystem]]'],\n        data   = internals.NumberFormat['[[localeData]]'][locale],\n        ild    = data.symbols[nums] || data.symbols.latn,\n        pattern,\n        result = new List();\n\n    if (!isNaN(x) && x < 0) {\n        x = -x;\n        pattern = internal['[[negativePattern]]'];\n    } else {\n        pattern = internal['[[positivePattern]]'];\n    }\n\n    let beginIndex = pattern.indexOf('{', 0),\n        endIndex = 0,\n        nextIndex = 0,\n        length = pattern.length;\n\n    while (beginIndex > -1 && beginIndex < length) {\n        endIndex = pattern.indexOf('}', beginIndex);\n        if (endIndex === -1)\n            throw new Error();\n\n        if (beginIndex > nextIndex)\n            arrPush.call(result, { type: 'literal', value: pattern.substring(nextIndex, beginIndex) });\n\n        let p = pattern.substring(beginIndex + 1, endIndex);\n\n        if (p === 'number') {\n            if (isNaN(x))\n                arrPush.call(result, { type: 'nan', value: ild.nan });\n            if (!isFinite(x))\n                arrPush.call(result, { type: 'infinity', value: ild.infinity });\n\n            // b. If the value of the [[style]] internal property of numberFormat is\n            //    \"percent\", let x be 100 × x.\n            if (internal['[[style]]'] === 'percent')\n                x *= 100;\n\n            let n;\n            // c. If the [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n            //    internal properties of numberFormat are present, then\n            if (hop.call(internal, '[[minimumSignificantDigits]]') &&\n                hop.call(internal, '[[maximumSignificantDigits]]'))\n                // i. Let n be the result of calling the ToRawPrecision abstract operation\n                //    (defined below), passing as arguments x and the values of the\n                //    [[minimumSignificantDigits]] and [[maximumSignificantDigits]]\n                //    internal properties of numberFormat.\n                n = ToRawPrecision(x,\n                      internal['[[minimumSignificantDigits]]'],\n                      internal['[[maximumSignificantDigits]]']);\n            // d. Else\n            else\n                // i. Let n be the result of calling the ToRawFixed abstract operation\n                //    (defined below), passing as arguments x and the values of the\n                //    [[minimumIntegerDigits]], [[minimumFractionDigits]], and\n                //    [[maximumFractionDigits]] internal properties of numberFormat.\n                n = ToRawFixed(x,\n                      internal['[[minimumIntegerDigits]]'],\n                      internal['[[minimumFractionDigits]]'],\n                      internal['[[maximumFractionDigits]]']);\n\n            // e. If the value of the [[numberingSystem]] internal property of\n            //    numberFormat matches one of the values in the “Numbering System” column\n            //    of Table 2 below, then\n            if (numSys[nums]) {\n                // i. Let digits be an array whose 10 String valued elements are the\n                //    UTF-16 string representations of the 10 digits specified in the\n                //    “Digits” column of Table 2 in the row containing the value of the\n                //    [[numberingSystem]] internal property.\n                let digits = numSys[internal['[[numberingSystem]]']];\n                // ii. Replace each digit in n with the value of digits[digit].\n                n = String(n).replace(/\\d/g, (digit) => {\n                  return digits[digit];\n                });\n            }\n            // f. Else use an implementation dependent algorithm to map n to the\n            //    appropriate representation of n in the given numbering system.\n            else\n                n = String(n); // ###TODO###\n\n            let decimalSplit = n.split('.');\n            let integer = decimalSplit[0];\n            let fraction = decimalSplit[1];\n\n            // h. If the value of the [[useGrouping]] internal property of numberFormat\n            //    is true, then insert an ILND String representing a grouping separator\n            //    into an ILND set of locations within the integer part of n.\n            if (internal['[[useGrouping]]'] === true) {\n                // Primary group represents the group closest to the decimal\n                let pgSize = data.patterns.primaryGroupSize || 3;\n\n                // Secondary group is every other group\n                let sgSize = data.patterns.secondaryGroupSize || pgSize;\n\n                let groups = new List();\n\n                // Group only if necessary\n                if (integer.length > pgSize) {\n                    // Index of the primary grouping separator\n                    let end    = integer.length - pgSize;\n\n                    // Starting index for our loop\n                    let idx    = end % sgSize;\n\n                    let start  = integer.slice(0, idx);\n\n                    if (start.length)\n                        arrPush.call(groups, start);\n\n                    // Loop to separate into secondary grouping digits\n                    while (idx < end) {\n                        arrPush.call(groups, integer.slice(idx, idx + sgSize));\n                        idx += sgSize;\n                    }\n\n                    // Add the primary grouping digits\n                    arrPush.call(groups, integer.slice(end));\n                } else {\n                    arrPush.call(groups, integer);\n                }\n\n                while (groups.length) {\n                    let integerGroup = arrShift.call(groups);\n                    arrPush.call(result, { type: 'integer', value: integerGroup });\n                    if (groups.length) {\n                        arrPush.call(result, { type: 'group', value: ild.group });\n                    }\n                }\n            } else {\n                arrPush.call(result, { type: 'integer', value: integer });\n            }\n\n            if (fraction !== undefined) {\n                arrPush.call(result, { type: 'decimal', value: ild.decimal });\n                arrPush.call(result, { type: 'fraction', value: fraction });\n            }\n\n        } else if (p === 'plusSign') {\n            arrPush.call(result, { type: 'plusSign', value: ild.plusSign });\n        } else if (p === 'minusSign') {\n            arrPush.call(result, { type: 'minusSign', value: ild.minusSign });\n        } else if (p === '{percentSign}' && internal['[[style]]'] === 'percent') {\n            arrPush.call(result, { type: 'percentSign', value: ild.percentSign });\n        } else if (p === 'currency' && internal['[[style]]'] === 'currency') {\n            let cd,\n            // a. Let currency be the value of the [[currency]] internal property of\n            //    numberFormat.\n                currency = internal['[[currency]]'],\n\n            // Shorthand for the currency data\n                cData = data.currencies[currency];\n\n            // b. If the value of the [[currencyDisplay]] internal property of\n            //    numberFormat is \"code\", then let cd be currency.\n            // c. Else if the value of the [[currencyDisplay]] internal property of\n            //    numberFormat is \"symbol\", then let cd be an ILD string representing\n            //    currency in short form. If the implementation does not have such a\n            //    representation of currency, then use currency itself.\n            // d. Else if the value of the [[currencyDisplay]] internal property of\n            //    numberFormat is \"name\", then let cd be an ILD string representing\n            //    currency in long form. If the implementation does not have such a\n            //    representation of currency, then use currency itself.\n            switch (internal['[[currencyDisplay]]']) {\n                case 'symbol':\n                    cd = cData || currency;\n                    break;\n\n                default:\n                case 'code':\n                case 'name':\n                    cd = currency;\n            }\n\n            arrPush.call(result, { type: 'currency', value: cd });\n        } else {\n            arrPush.call(result, { type: 'literal', value: pattern.substring(beginIndex, endIndex + 1) });\n        }\n\n        nextIndex = endIndex + 1;\n        beginIndex = pattern.indexOf('{', nextIndex);\n    }\n\n    if (nextIndex < length)\n        arrPush.call(result, { type: 'literal', value: pattern.substring(nextIndex, length) });\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // 7. Return result.\n    return result;\n}\n\nexport function FormatNumber (numberFormat, x) {\n    let parts = FormatNumberToParts(numberFormat, x);\n    let result = '';\n    for (let idx in parts) {\n        result += parts[idx].value;\n    }\n    return result;\n}\n\n/**\n * When the ToRawPrecision abstract operation is called with arguments x (which\n * must be a finite non-negative number), minPrecision, and maxPrecision (both\n * must be integers between 1 and 21) the following steps are taken:\n */\nfunction ToRawPrecision (x, minPrecision, maxPrecision) {\n    // 1. Let p be maxPrecision.\n    let p = maxPrecision;\n\n    let m, e;\n\n    // 2. If x = 0, then\n    if (x === 0) {\n        // a. Let m be the String consisting of p occurrences of the character \"0\".\n        m = arrJoin.call(Array (p + 1), '0');\n        // b. Let e be 0.\n        e = 0;\n    }\n    // 3. Else\n    else {\n        // a. Let e and n be integers such that 10ᵖ⁻¹ ≤ n < 10ᵖ and for which the\n        //    exact mathematical value of n × 10ᵉ⁻ᵖ⁺¹ – x is as close to zero as\n        //    possible. If there are two such sets of e and n, pick the e and n for\n        //    which n × 10ᵉ⁻ᵖ⁺¹ is larger.\n        e = log10Floor(Math.abs(x));\n\n        // Easier to get to m from here\n        let f = Math.round(Math.exp((Math.abs(e - p + 1)) * Math.LN10));\n\n        // b. Let m be the String consisting of the digits of the decimal\n        //    representation of n (in order, with no leading zeroes)\n        m = String(Math.round(e - p + 1 < 0 ? x * f : x / f));\n    }\n\n    // 4. If e ≥ p, then\n    if (e >= p)\n        // a. Return the concatenation of m and e-p+1 occurrences of the character \"0\".\n        return m + arrJoin.call(Array(e-p+1 + 1), '0');\n\n    // 5. If e = p-1, then\n    else if (e === p - 1)\n        // a. Return m.\n        return m;\n\n    // 6. If e ≥ 0, then\n    else if (e >= 0)\n        // a. Let m be the concatenation of the first e+1 characters of m, the character\n        //    \".\", and the remaining p–(e+1) characters of m.\n        m = m.slice(0, e + 1) + '.' + m.slice(e + 1);\n\n    // 7. If e < 0, then\n    else if (e < 0)\n        // a. Let m be the concatenation of the String \"0.\", –(e+1) occurrences of the\n        //    character \"0\", and the string m.\n        m = '0.' + arrJoin.call(Array (-(e+1) + 1), '0') + m;\n\n    // 8. If m contains the character \".\", and maxPrecision > minPrecision, then\n    if (m.indexOf(\".\") >= 0 && maxPrecision > minPrecision) {\n        // a. Let cut be maxPrecision – minPrecision.\n        let cut = maxPrecision - minPrecision;\n\n        // b. Repeat while cut > 0 and the last character of m is \"0\":\n        while (cut > 0 && m.charAt(m.length-1) === '0') {\n            //  i. Remove the last character from m.\n            m = m.slice(0, -1);\n\n            //  ii. Decrease cut by 1.\n            cut--;\n        }\n\n        // c. If the last character of m is \".\", then\n        if (m.charAt(m.length-1) === '.')\n            //    i. Remove the last character from m.\n            m = m.slice(0, -1);\n    }\n    // 9. Return m.\n    return m;\n}\n\n/**\n * When the ToRawFixed abstract operation is called with arguments x (which must\n * be a finite non-negative number), minInteger (which must be an integer between\n * 1 and 21), minFraction, and maxFraction (which must be integers between 0 and\n * 20) the following steps are taken:\n */\nfunction ToRawFixed (x, minInteger, minFraction, maxFraction) {\n    // (or not because Number.toPrototype.toFixed does a lot of it for us)\n    let idx,\n\n        // We can pick up after the fixed formatted string (m) is created\n        m   = Number.prototype.toFixed.call(x, maxFraction),\n\n        // 4. If [maxFraction] ≠ 0, then\n        //    ...\n        //    e. Let int be the number of characters in a.\n        //\n        // 5. Else let int be the number of characters in m.\n        igr = m.split(\".\")[0].length,  // int is a reserved word\n\n        // 6. Let cut be maxFraction – minFraction.\n        cut = maxFraction - minFraction,\n\n        exp = (idx = m.indexOf('e')) > -1 ? m.slice(idx + 1) : 0;\n\n    if (exp) {\n        m = m.slice(0, idx).replace('.', '');\n        m += arrJoin.call(Array(exp - (m.length - 1) + 1), '0')\n          + '.' + arrJoin.call(Array(maxFraction + 1), '0');\n\n        igr = m.length;\n    }\n\n    // 7. Repeat while cut > 0 and the last character of m is \"0\":\n    while (cut > 0 && m.slice(-1) === \"0\") {\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n\n        // b. Decrease cut by 1.\n        cut--;\n    }\n\n    // 8. If the last character of m is \".\", then\n    if (m.slice(-1) === \".\")\n        // a. Remove the last character from m.\n        m = m.slice(0, -1);\n\n    let z;\n    // 9. If int < minInteger, then\n    if (igr < minInteger)\n        // a. Let z be the String consisting of minInteger–int occurrences of the\n        //    character \"0\".\n        z = arrJoin.call(Array(minInteger - igr + 1), '0');\n\n    // 10. Let m be the concatenation of Strings z and m.\n    // 11. Return m.\n    return (z ? z : '') + m;\n}\n\n// Sect 11.3.2 Table 2, Numbering systems\n// ======================================\nlet numSys = {\n    arab: ['\\u0660', '\\u0661', '\\u0662', '\\u0663', '\\u0664', '\\u0665', '\\u0666', '\\u0667', '\\u0668', '\\u0669'],\n    arabext: ['\\u06F0', '\\u06F1', '\\u06F2', '\\u06F3', '\\u06F4', '\\u06F5', '\\u06F6', '\\u06F7', '\\u06F8', '\\u06F9'],\n    bali: ['\\u1B50', '\\u1B51', '\\u1B52', '\\u1B53', '\\u1B54', '\\u1B55', '\\u1B56', '\\u1B57', '\\u1B58', '\\u1B59'],\n    beng: ['\\u09E6', '\\u09E7', '\\u09E8', '\\u09E9', '\\u09EA', '\\u09EB', '\\u09EC', '\\u09ED', '\\u09EE', '\\u09EF'],\n    deva: ['\\u0966', '\\u0967', '\\u0968', '\\u0969', '\\u096A', '\\u096B', '\\u096C', '\\u096D', '\\u096E', '\\u096F'],\n    fullwide: ['\\uFF10', '\\uFF11', '\\uFF12', '\\uFF13', '\\uFF14', '\\uFF15', '\\uFF16', '\\uFF17', '\\uFF18', '\\uFF19'],\n    gujr: ['\\u0AE6', '\\u0AE7', '\\u0AE8', '\\u0AE9', '\\u0AEA', '\\u0AEB', '\\u0AEC', '\\u0AED', '\\u0AEE', '\\u0AEF'],\n    guru: ['\\u0A66', '\\u0A67', '\\u0A68', '\\u0A69', '\\u0A6A', '\\u0A6B', '\\u0A6C', '\\u0A6D', '\\u0A6E', '\\u0A6F'],\n    hanidec: ['\\u3007', '\\u4E00', '\\u4E8C', '\\u4E09', '\\u56DB', '\\u4E94', '\\u516D', '\\u4E03', '\\u516B', '\\u4E5D'],\n    khmr: ['\\u17E0', '\\u17E1', '\\u17E2', '\\u17E3', '\\u17E4', '\\u17E5', '\\u17E6', '\\u17E7', '\\u17E8', '\\u17E9'],\n    knda: ['\\u0CE6', '\\u0CE7', '\\u0CE8', '\\u0CE9', '\\u0CEA', '\\u0CEB', '\\u0CEC', '\\u0CED', '\\u0CEE', '\\u0CEF'],\n    laoo: ['\\u0ED0', '\\u0ED1', '\\u0ED2', '\\u0ED3', '\\u0ED4', '\\u0ED5', '\\u0ED6', '\\u0ED7', '\\u0ED8', '\\u0ED9'],\n    latn: ['\\u0030', '\\u0031', '\\u0032', '\\u0033', '\\u0034', '\\u0035', '\\u0036', '\\u0037', '\\u0038', '\\u0039'],\n    limb: ['\\u1946', '\\u1947', '\\u1948', '\\u1949', '\\u194A', '\\u194B', '\\u194C', '\\u194D', '\\u194E', '\\u194F'],\n    mlym: ['\\u0D66', '\\u0D67', '\\u0D68', '\\u0D69', '\\u0D6A', '\\u0D6B', '\\u0D6C', '\\u0D6D', '\\u0D6E', '\\u0D6F'],\n    mong: ['\\u1810', '\\u1811', '\\u1812', '\\u1813', '\\u1814', '\\u1815', '\\u1816', '\\u1817', '\\u1818', '\\u1819'],\n    mymr: ['\\u1040', '\\u1041', '\\u1042', '\\u1043', '\\u1044', '\\u1045', '\\u1046', '\\u1047', '\\u1048', '\\u1049'],\n    orya: ['\\u0B66', '\\u0B67', '\\u0B68', '\\u0B69', '\\u0B6A', '\\u0B6B', '\\u0B6C', '\\u0B6D', '\\u0B6E', '\\u0B6F'],\n    tamldec: ['\\u0BE6', '\\u0BE7', '\\u0BE8', '\\u0BE9', '\\u0BEA', '\\u0BEB', '\\u0BEC', '\\u0BED', '\\u0BEE', '\\u0BEF'],\n    telu: ['\\u0C66', '\\u0C67', '\\u0C68', '\\u0C69', '\\u0C6A', '\\u0C6B', '\\u0C6C', '\\u0C6D', '\\u0C6E', '\\u0C6F'],\n    thai: ['\\u0E50', '\\u0E51', '\\u0E52', '\\u0E53', '\\u0E54', '\\u0E55', '\\u0E56', '\\u0E57', '\\u0E58', '\\u0E59'],\n    tibt: ['\\u0F20', '\\u0F21', '\\u0F22', '\\u0F23', '\\u0F24', '\\u0F25', '\\u0F26', '\\u0F27', '\\u0F28', '\\u0F29'],\n};\n\n/**\n * This function provides access to the locale and formatting options computed\n * during initialization of the object.\n *\n * The function returns a new object whose properties and attributes are set as\n * if constructed by an object literal assigning to each of the following\n * properties the value of the corresponding internal property of this\n * NumberFormat object (see 11.4): locale, numberingSystem, style, currency,\n * currencyDisplay, minimumIntegerDigits, minimumFractionDigits,\n * maximumFractionDigits, minimumSignificantDigits, maximumSignificantDigits, and\n * useGrouping. Properties whose corresponding internal properties are not present\n * are not assigned.\n */\n/* 11.3.3 */defineProperty(Intl.NumberFormat.prototype, 'resolvedOptions', {\n    configurable: true,\n    writable: true,\n    value: function () {\n        let prop,\n            descs = new Record(),\n            props = [\n                'locale', 'numberingSystem', 'style', 'currency', 'currencyDisplay',\n                'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits',\n                'minimumSignificantDigits', 'maximumSignificantDigits', 'useGrouping',\n            ],\n            internal = this !== null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 11.3_b\n        if (!internal || !internal['[[initializedNumberFormat]]'])\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.NumberFormat object.');\n\n        for (let i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[['+ props[i] +']]'))\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    },\n});\n","/* jslint esnext: true */\n\n// Match these datetime components in a CLDR pattern, except those in single quotes\nlet expDTComponents = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n// trim patterns after transformations\nlet expPatternTrimmer = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\n// Skip over patterns with these datetime components because we don't have data\n// to back them up:\n// timezone, weekday, amoung others\nlet unwantedDTCs = /[rqQxXVOvZASjJgwWIQq]/;\n\nlet dtKeys = [\"weekday\", \"era\", \"year\", \"month\", \"day\", \"weekday\", \"quarter\"];\nlet tmKeys = [\"hour\", \"minute\", \"second\", \"hour12\", \"timeZoneName\"];\n\nfunction isDateFormatOnly(obj) {\n    for (let i = 0; i < tmKeys.length; i += 1) {\n        if (obj.hasOwnProperty(tmKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isTimeFormatOnly(obj) {\n    for (let i = 0; i < dtKeys.length; i += 1) {\n        if (obj.hasOwnProperty(dtKeys[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction joinDateAndTimeFormats(dateFormatObj, timeFormatObj) {\n    let o = {};\n    for (let i = 0; i < dtKeys.length; i += 1) {\n        if (dateFormatObj[dtKeys[i]]) {\n            o[dtKeys[i]] = dateFormatObj[dtKeys[i]];\n        }\n    }\n    for (let j = 0; j < tmKeys.length; j += 1) {\n        if (timeFormatObj[tmKeys[j]]) {\n            o[tmKeys[j]] = timeFormatObj[tmKeys[j]];\n        }\n    }\n    return o;\n}\n\nfunction computeFinalPatterns(formatObj) {\n    // From http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Format_Patterns:\n    //  'In patterns, two single quotes represents a literal single quote, either\n    //   inside or outside single quotes. Text within single quotes is not\n    //   interpreted in any way (except for two adjacent single quotes).'\n    formatObj.pattern12 = formatObj.extendedPattern.replace(/'([^']*)'/g, ($0, literal) => {\n        return literal ? literal : \"'\";\n    });\n\n    // pattern 12 is always the default. we can produce the 24 by removing {ampm}\n    formatObj.pattern = formatObj.pattern12.replace('{ampm}', '').replace(expPatternTrimmer, '');\n    return formatObj;\n}\n\n/**\n * Converts the CLDR availableFormats into the objects and patterns required by\n * the ECMAScript Internationalization API specification.\n */\nexport function createDateTimeFormat(skeleton, pattern) {\n    // we ignore certain patterns that are unsupported to avoid this expensive op.\n    if (unwantedDTCs.test(pattern))\n        return undefined;\n\n    let formatObj = {\n        originalPattern: pattern,\n    };\n\n    // Replace the pattern string with the one required by the specification, whilst\n    // at the same time evaluating it for the subsets and formats\n    formatObj.extendedPattern = pattern.replace(expDTComponents, ($0) => {\n        // See which symbol we're dealing with\n        switch ($0.charAt(0)) {\n\n            // --- Era\n            case 'G':\n                return '{era}';\n\n            // --- Year\n            case 'y':\n            case 'Y':\n            case 'u':\n            case 'U':\n            case 'r':\n                return '{year}';\n\n            // --- Quarter (not supported in this polyfill)\n            case 'Q':\n            case 'q':\n                return '{quarter}';\n\n            // --- Month\n            case 'M':\n            case 'L':\n                return '{month}';\n\n            // --- Week (not supported in this polyfill)\n            case 'w':\n            case 'W':\n                return '{weekday}';\n\n            // --- Day\n            case 'd':\n            case 'D':\n            case 'F':\n            case 'g':\n                return '{day}';\n\n            // --- Week Day\n            case 'E':\n            case 'e':\n            case 'c':\n                return '{weekday}';\n\n            // --- Period\n            case 'a':\n            case 'b':\n            case 'B':\n                return '{ampm}';\n\n            // --- Hour\n            case 'h':\n            case 'H':\n            case 'k':\n            case 'K':\n                return '{hour}';\n\n            // --- Minute\n            case 'm':\n                return '{minute}';\n\n            // --- Second\n            case 's':\n            case 'S':\n            case 'A':\n                return '{second}';\n\n            // --- Timezone\n            case 'z':\n            case 'Z':\n            case 'O':\n            case 'v':\n            case 'V':\n            case 'X':\n            case 'x':\n                return '{timeZoneName}';\n\n        }\n    });\n\n    // Match the skeleton string with the one required by the specification\n    // this implementation is based on the Date Field Symbol Table:\n    // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n    // Note: we are adding extra data to the formatObject even though this polyfill\n    //       might not support it.\n    skeleton.replace(expDTComponents, ($0) => {\n        // See which symbol we're dealing with\n        switch ($0.charAt(0)) {\n\n            // --- Era\n            case 'G':\n                formatObj.era = [ 'short', 'short', 'short', 'long', 'narrow' ][$0.length-1];\n                break;\n\n            // --- Year\n            case 'y':\n            case 'Y':\n            case 'u':\n            case 'U':\n                formatObj.year = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            // case 'r':\n                // r: 1..n - For the Gregorian calendar, the 'r' year is the same as the 'u' year.\n                // break;\n\n            // --- Quarter (not supported in this polyfill)\n            case 'Q':\n            case 'q':\n                formatObj.quarter = [ 'numeric', '2-digit', 'short', 'long', 'narrow' ][$0.length-1];\n                break;\n\n            // --- Month\n            case 'M':\n            case 'L':\n                formatObj.month = [ 'numeric', '2-digit', 'short', 'long', 'narrow' ][$0.length-1];\n                break;\n\n            // --- Week (not supported in this polyfill)\n            case 'w':\n                // week of the year\n                formatObj.week = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            case 'W':\n                // week of the month\n                formatObj.week = 'numeric';\n                break;\n\n            // --- Day\n            case 'd':\n                // day of the month\n                formatObj.day = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            case 'D':\n                // day of the year\n                formatObj.day = 'numeric';\n                break;\n            case 'F':\n                // day of the week\n                formatObj.day = 'numeric';\n                break;\n            // case 'g':\n                // 1..n: Modified Julian day\n                // break;\n\n            // --- Week Day\n            case 'E':\n                // day of the week\n                formatObj.weekday = [ 'short', 'short', 'short', 'long', 'narrow', 'short' ][$0.length-1];\n                break;\n            case 'e':\n                // local day of the week\n                formatObj.weekday = [ 'numeric', '2-digit', 'short', 'long', 'narrow', 'short' ][$0.length-1];\n                break;\n            case 'c':\n                // stand alone local day of the week\n                formatObj.weekday = [ 'numeric', undefined, 'short', 'long', 'narrow', 'short' ][$0.length-1];\n                break;\n\n            // --- Period\n            case 'a': // AM, PM\n            case 'b': // am, pm, noon, midnight\n            case 'B': // flexible day periods\n                formatObj.hour12 = true;\n                break;\n\n            // --- Hour\n            case 'H':\n            case 'k':\n                formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            case 'h':\n            case 'K':\n                formatObj.hour12 = true; // 12-hour-cycle time formats (using h or K)\n                formatObj.hour = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n\n            // --- Minute\n            case 'm':\n                formatObj.minute = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n\n            // --- Second\n            case 's':\n                formatObj.second = $0.length === 2 ? '2-digit' : 'numeric';\n                break;\n            // case 'S': // 1..n: factional seconds\n            // case 'A': // 1..n: miliseconds in day\n\n            // --- Timezone\n            case 'z': // 1..3, 4: specific non-location format\n            case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n            case 'O': // 1, 4: miliseconds in day short, long\n            case 'v': // 1, 4: generic non-location format\n            case 'V': // 1, 2, 3, 4: time zone ID or city\n            case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n            case 'x': // 1, 2, 3, 4: The ISO8601 varios formats\n                // this polyfill only supports much, for now, we are just doing something dummy\n                formatObj.timeZoneName = $0.length < 4 ? 'short' : 'long';\n                break;\n\n        }\n    });\n\n    return computeFinalPatterns(formatObj);\n}\n\n/**\n * Processes DateTime formats from CLDR to an easier-to-parse format.\n * the result of this operation should be cached the first time a particular\n * calendar is analyzed.\n *\n * The specification requires we support at least the following subsets of\n * date/time components:\n *\n *   - 'weekday', 'year', 'month', 'day', 'hour', 'minute', 'second'\n *   - 'weekday', 'year', 'month', 'day'\n *   - 'year', 'month', 'day'\n *   - 'year', 'month'\n *   - 'month', 'day'\n *   - 'hour', 'minute', 'second'\n *   - 'hour', 'minute'\n *\n * We need to cherry pick at least these subsets from the CLDR data and convert\n * them into the pattern objects used in the ECMA-402 API.\n */\nexport function createDateTimeFormats(formats) {\n    let availableFormats = formats.availableFormats;\n    let timeFormats = formats.timeFormats;\n    let dateFormats = formats.dateFormats;\n    let result = [];\n    let skeleton, pattern, computed, i, j;\n    let timeRelatedFormats = [];\n    let dateRelatedFormats = [];\n\n    // Map available (custom) formats into a pattern for createDateTimeFormats\n    for (skeleton in availableFormats) {\n        if (availableFormats.hasOwnProperty(skeleton)) {\n            pattern = availableFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                // in some cases, the format is only displaying date specific props\n                // or time specific props, in which case we need to also produce the\n                // combined formats.\n                if (isDateFormatOnly(computed)) {\n                    dateRelatedFormats.push(computed);\n                } else if (isTimeFormatOnly(computed)) {\n                    timeRelatedFormats.push(computed);\n                }\n            }\n        }\n    }\n\n    // Map time formats into a pattern for createDateTimeFormats\n    for (skeleton in timeFormats) {\n        if (timeFormats.hasOwnProperty(skeleton)) {\n            pattern = timeFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                timeRelatedFormats.push(computed);\n            }\n        }\n    }\n\n    // Map date formats into a pattern for createDateTimeFormats\n    for (skeleton in dateFormats) {\n        if (dateFormats.hasOwnProperty(skeleton)) {\n            pattern = dateFormats[skeleton];\n            computed = createDateTimeFormat(skeleton, pattern);\n            if (computed) {\n                result.push(computed);\n                dateRelatedFormats.push(computed);\n            }\n        }\n    }\n\n    // combine custom time and custom date formats when they are orthogonals to complete the\n    // formats supported by CLDR.\n    // This Algo is based on section \"Missing Skeleton Fields\" from:\n    // http://unicode.org/reports/tr35/tr35-dates.html#availableFormats_appendItems\n    for (i = 0; i < timeRelatedFormats.length; i += 1) {\n        for (j = 0; j < dateRelatedFormats.length; j += 1) {\n            if (dateRelatedFormats[j].month === 'long') {\n                pattern = dateRelatedFormats[j].weekday ? formats.full : formats.long;\n            } else if (dateRelatedFormats[j].month === 'short') {\n                pattern = formats.medium;\n            } else {\n                pattern = formats.short;\n            }\n            computed = joinDateAndTimeFormats(dateRelatedFormats[j], timeRelatedFormats[i]);\n            computed.originalPattern = pattern;\n            computed.extendedPattern = pattern\n                .replace('{0}', timeRelatedFormats[i].extendedPattern)\n                .replace('{1}', dateRelatedFormats[j].extendedPattern)\n                .replace(/^[,\\s]+|[,\\s]+$/gi, '');\n            result.push(computeFinalPatterns(computed));\n        }\n    }\n\n    return result;\n}\n","// 12.1 The Intl.DateTimeFormat constructor\n// ==================================\n\nimport {\n    toLatinUpperCase,\n} from './6.locales-currencies-tz.js';\n\nimport {\n    Intl,\n} from \"./8.intl.js\";\n\nimport {\n    CanonicalizeLocaleList,\n    ResolveLocale,\n    GetOption,\n    SupportedLocales,\n} from \"./9.negotiation.js\";\n\nimport {\n    FormatNumber,\n} from \"./11.numberformat.js\";\n\nimport {\n    createDateTimeFormats,\n} from \"./cldr\";\n\nimport {\n    internals,\n    es3,\n    fnBind,\n    defineProperty,\n    toObject,\n    getInternalProperties,\n    createRegExpRestore,\n    secret,\n    Record,\n    List,\n    hop,\n    objCreate,\n    arrPush,\n    arrIndexOf,\n} from './util.js';\n\n// An object map of date component keys, saves using a regex later\nconst dateWidths = objCreate(null, { narrow:{}, short:{}, long:{} });\n\n/**\n * Returns a string for a date component, resolved using multiple inheritance as specified\n * as specified in the Unicode Technical Standard 35.\n */\nfunction resolveDateString(data, ca, component, width, key) {\n    // From http://www.unicode.org/reports/tr35/tr35.html#Multiple_Inheritance:\n    // 'In clearly specified instances, resources may inherit from within the same locale.\n    //  For example, ... the Buddhist calendar inherits from the Gregorian calendar.'\n    let obj = data[ca] && data[ca][component]\n                ? data[ca][component]\n                : data.gregory[component],\n\n        // \"sideways\" inheritance resolves strings when a key doesn't exist\n        alts = {\n            narrow: ['short', 'long'],\n            short:  ['long', 'narrow'],\n            long:   ['short', 'narrow'],\n        },\n\n        //\n        resolved = hop.call(obj, width)\n                  ? obj[width]\n                  : hop.call(obj, alts[width][0])\n                      ? obj[alts[width][0]]\n                      : obj[alts[width][1]];\n\n    // `key` wouldn't be specified for components 'dayPeriods'\n    return key !== null ? resolved[key] : resolved;\n}\n\n// Define the DateTimeFormat constructor internally so it cannot be tainted\nexport function DateTimeFormatConstructor () {\n    let locales = arguments[0];\n    let options = arguments[1];\n\n    if (!this || this === Intl) {\n        return new Intl.DateTimeFormat(locales, options);\n    }\n    return InitializeDateTimeFormat(toObject(this), locales, options);\n}\n\ndefineProperty(Intl, 'DateTimeFormat', {\n    configurable: true,\n    writable: true,\n    value: DateTimeFormatConstructor,\n});\n\n// Must explicitly set prototypes as unwritable\ndefineProperty(DateTimeFormatConstructor, 'prototype', {\n    writable: false,\n});\n\n/**\n * The abstract operation InitializeDateTimeFormat accepts the arguments dateTimeFormat\n * (which must be an object), locales, and options. It initializes dateTimeFormat as a\n * DateTimeFormat object.\n */\nexport function/* 12.1.1.1 */InitializeDateTimeFormat (dateTimeFormat, locales, options) {\n    // This will be a internal properties object if we're not already initialized\n    let internal = getInternalProperties(dateTimeFormat);\n\n    // Create an object whose props can be used to restore the values of RegExp props\n    let regexpState = createRegExpRestore();\n\n    // 1. If dateTimeFormat has an [[initializedIntlObject]] internal property with\n    //    value true, throw a TypeError exception.\n    if (internal['[[initializedIntlObject]]'] === true)\n        throw new TypeError('`this` object has already been initialized as an Intl object');\n\n    // Need this to access the `internal` object\n    defineProperty(dateTimeFormat, '__getInternalProperties', {\n        value: function () {\n            // NOTE: Non-standard, for internal use only\n            if (arguments[0] === secret)\n                return internal;\n        },\n    });\n\n    // 2. Set the [[initializedIntlObject]] internal property of numberFormat to true.\n    internal['[[initializedIntlObject]]'] = true;\n\n    // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n    //    abstract operation (defined in 9.2.1) with argument locales.\n    let requestedLocales = CanonicalizeLocaleList(locales);\n\n    // 4. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined below) with arguments options, \"any\", and \"date\".\n    options = ToDateTimeOptions(options, 'any', 'date');\n\n    // 5. Let opt be a new Record.\n    let opt = new Record();\n\n    // 6. Let matcher be the result of calling the GetOption abstract operation\n    //    (defined in 9.2.9) with arguments options, \"localeMatcher\", \"string\", a List\n    //    containing the two String values \"lookup\" and \"best fit\", and \"best fit\".\n    let matcher = GetOption(options, 'localeMatcher', 'string', new List('lookup', 'best fit'), 'best fit');\n\n    // 7. Set opt.[[localeMatcher]] to matcher.\n    opt['[[localeMatcher]]'] = matcher;\n\n    // 8. Let DateTimeFormat be the standard built-in object that is the initial\n    //    value of Intl.DateTimeFormat.\n    let DateTimeFormat = internals.DateTimeFormat; // This is what we *really* need\n\n    // 9. Let localeData be the value of the [[localeData]] internal property of\n    //    DateTimeFormat.\n    let localeData = DateTimeFormat['[[localeData]]'];\n\n    // 10. Let r be the result of calling the ResolveLocale abstract operation\n    //     (defined in 9.2.5) with the [[availableLocales]] internal property of\n    //      DateTimeFormat, requestedLocales, opt, the [[relevantExtensionKeys]]\n    //      internal property of DateTimeFormat, and localeData.\n    let r = ResolveLocale(DateTimeFormat['[[availableLocales]]'], requestedLocales,\n                opt, DateTimeFormat['[[relevantExtensionKeys]]'], localeData);\n\n    // 11. Set the [[locale]] internal property of dateTimeFormat to the value of\n    //     r.[[locale]].\n    internal['[[locale]]'] = r['[[locale]]'];\n\n    // 12. Set the [[calendar]] internal property of dateTimeFormat to the value of\n    //     r.[[ca]].\n    internal['[[calendar]]'] = r['[[ca]]'];\n\n    // 13. Set the [[numberingSystem]] internal property of dateTimeFormat to the value of\n    //     r.[[nu]].\n    internal['[[numberingSystem]]'] = r['[[nu]]'];\n\n    // The specification doesn't tell us to do this, but it's helpful later on\n    internal['[[dataLocale]]'] = r['[[dataLocale]]'];\n\n    // 14. Let dataLocale be the value of r.[[dataLocale]].\n    let dataLocale = r['[[dataLocale]]'];\n\n    // 15. Let tz be the result of calling the [[Get]] internal method of options with\n    //     argument \"timeZone\".\n    let tz = options.timeZone;\n\n    // 16. If tz is not undefined, then\n    if (tz !== undefined) {\n        // a. Let tz be ToString(tz).\n        // b. Convert tz to upper case as described in 6.1.\n        //    NOTE: If an implementation accepts additional time zone values, as permitted\n        //          under certain conditions by the Conformance clause, different casing\n        //          rules apply.\n        tz = toLatinUpperCase(tz);\n\n        // c. If tz is not \"UTC\", then throw a RangeError exception.\n        // ###TODO: accept more time zones###\n        if (tz !== 'UTC')\n            throw new RangeError('timeZone is not supported.');\n    }\n\n    // 17. Set the [[timeZone]] internal property of dateTimeFormat to tz.\n    internal['[[timeZone]]'] = tz;\n\n    // 18. Let opt be a new Record.\n    opt = new Record();\n\n    // 19. For each row of Table 3, except the header row, do:\n    for (let prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop))\n            continue;\n\n        // 20. Let prop be the name given in the Property column of the row.\n        // 21. Let value be the result of calling the GetOption abstract operation,\n        //     passing as argument options, the name given in the Property column of the\n        //     row, \"string\", a List containing the strings given in the Values column of\n        //     the row, and undefined.\n        let value = GetOption(options, prop, 'string', dateTimeComponents[prop]);\n\n        // 22. Set opt.[[<prop>]] to value.\n        opt['[['+prop+']]'] = value;\n    }\n\n    // Assigned a value below\n    let bestFormat;\n\n    // 23. Let dataLocaleData be the result of calling the [[Get]] internal method of\n    //     localeData with argument dataLocale.\n    let dataLocaleData = localeData[dataLocale];\n\n    // 24. Let formats be the result of calling the [[Get]] internal method of\n    //     dataLocaleData with argument \"formats\".\n    //     Note: we process the CLDR formats into the spec'd structure\n    let formats = ToDateTimeFormats(dataLocaleData.formats);\n\n    // 25. Let matcher be the result of calling the GetOption abstract operation with\n    //     arguments options, \"formatMatcher\", \"string\", a List containing the two String\n    //     values \"basic\" and \"best fit\", and \"best fit\".\n    matcher = GetOption(options, 'formatMatcher', 'string', new List('basic', 'best fit'), 'best fit');\n\n    // Optimization: caching the processed formats as a one time operation by\n    // replacing the initial structure from localeData\n    dataLocaleData.formats = formats;\n\n    // 26. If matcher is \"basic\", then\n    if (matcher === 'basic')\n        // 27. Let bestFormat be the result of calling the BasicFormatMatcher abstract\n        //     operation (defined below) with opt and formats.\n        bestFormat = BasicFormatMatcher(opt, formats);\n\n    // 28. Else\n    else\n        // 29. Let bestFormat be the result of calling the BestFitFormatMatcher\n        //     abstract operation (defined below) with opt and formats.\n        bestFormat = BestFitFormatMatcher(opt, formats);\n\n    // 30. For each row in Table 3, except the header row, do\n    for (let prop in dateTimeComponents) {\n        if (!hop.call(dateTimeComponents, prop))\n            continue;\n\n        // a. Let prop be the name given in the Property column of the row.\n        // b. Let pDesc be the result of calling the [[GetOwnProperty]] internal method of\n        //    bestFormat with argument prop.\n        // c. If pDesc is not undefined, then\n        if (hop.call(bestFormat, prop)) {\n            // i. Let p be the result of calling the [[Get]] internal method of bestFormat\n            //    with argument prop.\n            let p = bestFormat[prop];\n\n            // ii. Set the [[<prop>]] internal property of dateTimeFormat to p.\n            // Diverging from spec becuase of bug #58\n            // https://github.com/tc39/ecma402/issues/58\n            internal['[['+prop+']]'] = opt['[['+prop+']]'] || p;\n        }\n    }\n\n    // Assigned a value below\n    let pattern;\n\n    // 31. Let hr12 be the result of calling the GetOption abstract operation with\n    //     arguments options, \"hour12\", \"boolean\", undefined, and undefined.\n    let hr12 = GetOption(options, 'hour12', 'boolean'/*, undefined, undefined*/);\n\n    // 32. If dateTimeFormat has an internal property [[hour]], then\n    if (internal['[[hour]]']) {\n        // a. If hr12 is undefined, then let hr12 be the result of calling the [[Get]]\n        //    internal method of dataLocaleData with argument \"hour12\".\n        hr12 = hr12 === undefined ? dataLocaleData.hour12 : hr12;\n\n        // b. Set the [[hour12]] internal property of dateTimeFormat to hr12.\n        internal['[[hour12]]'] = hr12;\n\n        // c. If hr12 is true, then\n        if (hr12 === true) {\n            // i. Let hourNo0 be the result of calling the [[Get]] internal method of\n            //    dataLocaleData with argument \"hourNo0\".\n            let hourNo0 = dataLocaleData.hourNo0;\n\n            // ii. Set the [[hourNo0]] internal property of dateTimeFormat to hourNo0.\n            internal['[[hourNo0]]'] = hourNo0;\n\n            // iii. Let pattern be the result of calling the [[Get]] internal method of\n            //      bestFormat with argument \"pattern12\".\n            pattern = bestFormat.pattern12;\n        }\n\n        // d. Else\n        else\n            // i. Let pattern be the result of calling the [[Get]] internal method of\n            //    bestFormat with argument \"pattern\".\n            pattern = bestFormat.pattern;\n    }\n\n    // 33. Else\n    else\n        // a. Let pattern be the result of calling the [[Get]] internal method of\n        //    bestFormat with argument \"pattern\".\n        pattern = bestFormat.pattern;\n\n    // 34. Set the [[pattern]] internal property of dateTimeFormat to pattern.\n    internal['[[pattern]]'] = pattern;\n\n    // 35. Set the [[boundFormat]] internal property of dateTimeFormat to undefined.\n    internal['[[boundFormat]]'] = undefined;\n\n    // 36. Set the [[initializedDateTimeFormat]] internal property of dateTimeFormat to\n    //     true.\n    internal['[[initializedDateTimeFormat]]'] = true;\n\n    // In ES3, we need to pre-bind the format() function\n    if (es3)\n        dateTimeFormat.format = GetFormatDateTime.call(dateTimeFormat);\n\n    // Restore the RegExp properties\n    regexpState.exp.test(regexpState.input);\n\n    // Return the newly initialised object\n    return dateTimeFormat;\n}\n\n/**\n * Several DateTimeFormat algorithms use values from the following table, which provides\n * property names and allowable values for the components of date and time formats:\n */\nlet dateTimeComponents = {\n         weekday: [ \"narrow\", \"short\", \"long\" ],\n             era: [ \"narrow\", \"short\", \"long\" ],\n            year: [ \"2-digit\", \"numeric\" ],\n           month: [ \"2-digit\", \"numeric\", \"narrow\", \"short\", \"long\" ],\n             day: [ \"2-digit\", \"numeric\" ],\n            hour: [ \"2-digit\", \"numeric\" ],\n          minute: [ \"2-digit\", \"numeric\" ],\n          second: [ \"2-digit\", \"numeric\" ],\n    timeZoneName: [ \"short\", \"long\" ],\n};\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nfunction ToDateTimeFormats(formats) {\n    if (Object.prototype.toString.call(formats) === '[object Array]') {\n        return formats;\n    }\n    return createDateTimeFormats(formats);\n}\n\n/**\n * When the ToDateTimeOptions abstract operation is called with arguments options,\n * required, and defaults, the following steps are taken:\n */\nexport function ToDateTimeOptions (options, required, defaults) {\n    // 1. If options is undefined, then let options be null, else let options be\n    //    ToObject(options).\n    if (options === undefined)\n        options = null;\n\n    else {\n        // (#12) options needs to be a Record, but it also needs to inherit properties\n        let opt2 = toObject(options);\n        options = new Record();\n\n        for (let k in opt2)\n            options[k] = opt2[k];\n    }\n\n    // 2. Let create be the standard built-in function object defined in ES5, 15.2.3.5.\n    let create = objCreate;\n\n    // 3. Let options be the result of calling the [[Call]] internal method of create with\n    //    undefined as the this value and an argument list containing the single item\n    //    options.\n    options = create(options);\n\n    // 4. Let needDefaults be true.\n    let needDefaults = true;\n\n    // 5. If required is \"date\" or \"any\", then\n    if (required === 'date' || required === 'any') {\n        // a. For each of the property names \"weekday\", \"year\", \"month\", \"day\":\n            // i. If the result of calling the [[Get]] internal method of options with the\n            //    property name is not undefined, then let needDefaults be false.\n        if (options.weekday !== undefined || options.year !== undefined\n                || options.month !== undefined || options.day !== undefined)\n            needDefaults = false;\n    }\n\n    // 6. If required is \"time\" or \"any\", then\n    if (required === 'time' || required === 'any') {\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n            // i. If the result of calling the [[Get]] internal method of options with the\n            //    property name is not undefined, then let needDefaults be false.\n        if (options.hour !== undefined || options.minute !== undefined || options.second !== undefined)\n                needDefaults = false;\n    }\n\n    // 7. If needDefaults is true and defaults is either \"date\" or \"all\", then\n    if (needDefaults && (defaults === 'date' || defaults === 'all'))\n        // a. For each of the property names \"year\", \"month\", \"day\":\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.year = options.month = options.day = 'numeric';\n\n    // 8. If needDefaults is true and defaults is either \"time\" or \"all\", then\n    if (needDefaults && (defaults === 'time' || defaults === 'all'))\n        // a. For each of the property names \"hour\", \"minute\", \"second\":\n            // i. Call the [[DefineOwnProperty]] internal method of options with the\n            //    property name, Property Descriptor {[[Value]]: \"numeric\", [[Writable]]:\n            //    true, [[Enumerable]]: true, [[Configurable]]: true}, and false.\n        options.hour = options.minute = options.second = 'numeric';\n\n    // 9. Return options.\n    return options;\n}\n\n/**\n * When the BasicFormatMatcher abstract operation is called with two arguments options and\n * formats, the following steps are taken:\n */\nfunction BasicFormatMatcher (options, formats) {\n    return calculateScore(options, formats);\n}\n\n/**\n * Calculates score for BestFitFormatMatcher and BasicFormatMatcher.\n * Abstracted from BasicFormatMatcher section.\n */\nfunction calculateScore (options, formats, bestFit) {\n    // Additional penalty type when bestFit === true\n    let diffDataTypePenalty = 8;\n\n    // 1. Let removalPenalty be 120.\n    let removalPenalty = 120;\n\n    // 2. Let additionPenalty be 20.\n    let additionPenalty = 20;\n\n    // 3. Let longLessPenalty be 8.\n    let longLessPenalty = 8;\n\n    // 4. Let longMorePenalty be 6.\n    let longMorePenalty = 6;\n\n    // 5. Let shortLessPenalty be 6.\n    let shortLessPenalty = 6;\n\n    // 6. Let shortMorePenalty be 3.\n    let shortMorePenalty = 3;\n\n    // 7. Let bestScore be -Infinity.\n    let bestScore = -Infinity;\n\n    // 8. Let bestFormat be undefined.\n    let bestFormat;\n\n    // 9. Let i be 0.\n    let i = 0;\n\n    // 10. Let len be the result of calling the [[Get]] internal method of formats with argument \"length\".\n    let len = formats.length;\n\n    // 11. Repeat while i < len:\n    while (i < len) {\n        // a. Let format be the result of calling the [[Get]] internal method of formats with argument ToString(i).\n        let format = formats[i];\n\n        // b. Let score be 0.\n        let score = 0;\n\n        // c. For each property shown in Table 3:\n        for (let property in dateTimeComponents) {\n            if (!hop.call(dateTimeComponents, property))\n                continue;\n\n            // i. Let optionsProp be options.[[<property>]].\n            let optionsProp = options['[['+ property +']]'];\n\n            // ii. Let formatPropDesc be the result of calling the [[GetOwnProperty]] internal method of format\n            //     with argument property.\n            // iii. If formatPropDesc is not undefined, then\n            //     1. Let formatProp be the result of calling the [[Get]] internal method of format with argument property.\n            let formatProp = hop.call(format, property) ? format[property] : undefined;\n\n            // iv. If optionsProp is undefined and formatProp is not undefined, then decrease score by\n            //     additionPenalty.\n            if (optionsProp === undefined && formatProp !== undefined)\n                score -= additionPenalty;\n\n            // v. Else if optionsProp is not undefined and formatProp is undefined, then decrease score by\n            //    removalPenalty.\n            else if (optionsProp !== undefined && formatProp === undefined)\n                score -= removalPenalty;\n\n            // vi. Else\n            else {\n                // 1. Let values be the array [\"2-digit\", \"numeric\", \"narrow\", \"short\",\n                //    \"long\"].\n                let values = [ '2-digit', 'numeric', 'narrow', 'short', 'long' ];\n\n                // 2. Let optionsPropIndex be the index of optionsProp within values.\n                let optionsPropIndex = arrIndexOf.call(values, optionsProp);\n\n                // 3. Let formatPropIndex be the index of formatProp within values.\n                let formatPropIndex = arrIndexOf.call(values, formatProp);\n\n                // 4. Let delta be max(min(formatPropIndex - optionsPropIndex, 2), -2).\n                let delta = Math.max(Math.min(formatPropIndex - optionsPropIndex, 2), -2);\n\n                // When the bestFit argument is true, subtract additional penalty where data types are not the same\n                if (bestFit && (\n                    ((optionsProp === 'numeric' || optionsProp === '2-digit') && (formatProp !== 'numeric' && formatProp !== '2-digit'))\n                 || ((optionsProp !== 'numeric' && optionsProp !== '2-digit') && (formatProp === '2-digit' || formatProp === 'numeric'))\n                ))\n                    score -= diffDataTypePenalty;\n\n                // 5. If delta = 2, decrease score by longMorePenalty.\n                if (delta === 2)\n                    score -= longMorePenalty;\n\n                // 6. Else if delta = 1, decrease score by shortMorePenalty.\n                else if (delta === 1)\n                    score -= shortMorePenalty;\n\n                // 7. Else if delta = -1, decrease score by shortLessPenalty.\n                else if (delta === -1)\n                    score -= shortLessPenalty;\n\n                // 8. Else if delta = -2, decrease score by longLessPenalty.\n                else if (delta === -2)\n                    score -= longLessPenalty;\n            }\n        }\n\n        // d. If score > bestScore, then\n        if (score > bestScore) {\n            // i. Let bestScore be score.\n            bestScore = score;\n\n            // ii. Let bestFormat be format.\n            bestFormat = format;\n        }\n\n        // e. Increase i by 1.\n        i++;\n    }\n\n    // 12. Return bestFormat.\n    return bestFormat;\n}\n\n/**\n * When the BestFitFormatMatcher abstract operation is called with two arguments options\n * and formats, it performs implementation dependent steps, which should return a set of\n * component representations that a typical user of the selected locale would perceive as\n * at least as good as the one returned by BasicFormatMatcher.\n *\n * This polyfill defines the algorithm to be the same as BasicFormatMatcher,\n * with the addition of bonus points awarded where the requested format is of\n * the same data type as the potentially matching format.\n *\n * For example,\n *\n *     { month: 'numeric', day: 'numeric' }\n *\n * should match\n *\n *     { month: '2-digit', day: '2-digit' }\n *\n * rather than\n *\n *     { month: 'short', day: 'numeric' }\n *\n * This makes sense because a user requesting a formatted date with numeric parts would\n * not expect to see the returned format containing narrow, short or long part names\n */\nfunction BestFitFormatMatcher (options, formats) {\n    return calculateScore(options, formats, true);\n}\n\n/* 12.2.3 */internals.DateTimeFormat = {\n    '[[availableLocales]]': [],\n    '[[relevantExtensionKeys]]': ['ca', 'nu'],\n    '[[localeData]]': {},\n};\n\n/**\n * When the supportedLocalesOf method of Intl.DateTimeFormat is called, the\n * following steps are taken:\n */\n/* 12.2.2 */\ndefineProperty(Intl.DateTimeFormat, 'supportedLocalesOf', {\n    configurable: true,\n    writable: true,\n    value: fnBind.call(function (locales) {\n        // Bound functions only have the `this` value altered if being used as a constructor,\n        // this lets us imitate a native function that has no constructor\n        if (!hop.call(this, '[[availableLocales]]'))\n            throw new TypeError('supportedLocalesOf() is not a constructor');\n\n        // Create an object whose props can be used to restore the values of RegExp props\n        let regexpState = createRegExpRestore(),\n\n        // 1. If options is not provided, then let options be undefined.\n            options = arguments[1],\n\n        // 2. Let availableLocales be the value of the [[availableLocales]] internal\n        //    property of the standard built-in object that is the initial value of\n        //    Intl.NumberFormat.\n\n            availableLocales = this['[[availableLocales]]'],\n\n        // 3. Let requestedLocales be the result of calling the CanonicalizeLocaleList\n        //    abstract operation (defined in 9.2.1) with argument locales.\n            requestedLocales = CanonicalizeLocaleList(locales);\n\n        // Restore the RegExp properties\n        regexpState.exp.test(regexpState.input);\n\n        // 4. Return the result of calling the SupportedLocales abstract operation\n        //    (defined in 9.2.8) with arguments availableLocales, requestedLocales,\n        //    and options.\n        return SupportedLocales(availableLocales, requestedLocales, options);\n    }, internals.NumberFormat),\n});\n\n/**\n * This named accessor property returns a function that formats a number\n * according to the effective locale and the formatting options of this\n * DateTimeFormat object.\n */\n/* 12.3.2 */defineProperty(Intl.DateTimeFormat.prototype, 'format', {\n    configurable: true,\n    get: GetFormatDateTime,\n});\n\ndefineProperty(Intl.DateTimeFormat.prototype, 'formatToParts', {\n    configurable: true,\n    get: GetFormatToPartsDateTime,\n});\n\nfunction GetFormatDateTime() {\n    let internal = this !== null && typeof this === 'object' && getInternalProperties(this);\n\n    // Satisfy test 12.3_b\n    if (!internal || !internal['[[initializedDateTimeFormat]]'])\n        throw new TypeError('`this` value for format() is not an initialized Intl.DateTimeFormat object.');\n\n    // The value of the [[Get]] attribute is a function that takes the following\n    // steps:\n\n    // 1. If the [[boundFormat]] internal property of this DateTimeFormat object\n    //    is undefined, then:\n    if (internal['[[boundFormat]]'] === undefined) {\n        // a. Let F be a Function object, with internal properties set as\n        //    specified for built-in functions in ES5, 15, or successor, and the\n        //    length property set to 0, that takes the argument date and\n        //    performs the following steps:\n        let F = function () {\n                //   i. If date is not provided or is undefined, then let x be the\n                //      result as if by the expression Date.now() where Date.now is\n                //      the standard built-in function defined in ES5, 15.9.4.4.\n                //  ii. Else let x be ToNumber(date).\n                // iii. Return the result of calling the FormatDateTime abstract\n                //      operation (defined below) with arguments this and x.\n                let x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n                return FormatDateTime(this, x);\n            };\n        // b. Let bind be the standard built-in function object defined in ES5,\n        //    15.3.4.5.\n        // c. Let bf be the result of calling the [[Call]] internal method of\n        //    bind with F as the this value and an argument list containing\n        //    the single item this.\n        let bf = fnBind.call(F, this);\n        // d. Set the [[boundFormat]] internal property of this NumberFormat\n        //    object to bf.\n        internal['[[boundFormat]]'] = bf;\n    }\n    // Return the value of the [[boundFormat]] internal property of this\n    // NumberFormat object.\n    return internal['[[boundFormat]]'];\n}\n\nfunction GetFormatToPartsDateTime() {\n    let internal = this !== null && typeof this === 'object' && getInternalProperties(this);\n\n    if (!internal || !internal['[[initializedDateTimeFormat]]'])\n        throw new TypeError('`this` value for formatToParts() is not an initialized Intl.DateTimeFormat object.');\n\n    if (internal['[[boundFormatToParts]]'] === undefined) {\n        let F = function () {\n                let x = Number(arguments.length === 0 ? Date.now() : arguments[0]);\n                return FormatToPartsDateTime(this, x);\n            };\n        let bf = fnBind.call(F, this);\n        internal['[[boundFormatToParts]]'] = bf;\n    }\n    return internal['[[boundFormatToParts]]'];\n}\n\nfunction CreateDateTimeParts(dateTimeFormat, x) {\n    // 1. If x is not a finite Number, then throw a RangeError exception.\n    if (!isFinite(x))\n        throw new RangeError('Invalid valid date passed to format');\n\n    let internal = dateTimeFormat.__getInternalProperties(secret);\n\n    // Creating restore point for properties on the RegExp object... please wait\n    /* let regexpState = */createRegExpRestore(); // todo: review this\n\n    // 2. Let locale be the value of the [[locale]] internal property of dateTimeFormat.\n    let locale = internal['[[locale]]'];\n\n    // 3. Let nf be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {useGrouping: false}) where\n    // Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n    let nf = new Intl.NumberFormat([locale], {useGrouping: false});\n\n    // 4. Let nf2 be the result of creating a new NumberFormat object as if by the\n    // expression new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping:\n    // false}) where Intl.NumberFormat is the standard built-in constructor defined in\n    // 11.1.3.\n    let nf2 = new Intl.NumberFormat([locale], {minimumIntegerDigits: 2, useGrouping: false});\n\n    // 5. Let tm be the result of calling the ToLocalTime abstract operation (defined\n    // below) with x, the value of the [[calendar]] internal property of dateTimeFormat,\n    // and the value of the [[timeZone]] internal property of dateTimeFormat.\n    let tm = ToLocalTime(x, internal['[[calendar]]'], internal['[[timeZone]]']);\n\n    // 6. Let result be the value of the [[pattern]] internal property of dateTimeFormat.\n    let pattern = internal['[[pattern]]'];\n\n    // 7.\n    let result = new List();\n\n    // 8.\n    let index = 0;\n\n    // 9.\n    let beginIndex = pattern.indexOf('{');\n\n    // 10.\n    let endIndex = 0;\n\n    // Need the locale minus any extensions\n    let dataLocale = internal['[[dataLocale]]'];\n\n    // Need the calendar data from CLDR\n    let localeData = internals.DateTimeFormat['[[localeData]]'][dataLocale].calendars;\n    let ca = internal['[[calendar]]'];\n\n    // 11.\n        while (beginIndex !== -1) {\n            let fv;\n            // a.\n            endIndex = pattern.indexOf('}', beginIndex);\n            // b.\n            if (endIndex === -1) {\n              throw new Error('Unclosed pattern');\n            }\n            // c.\n            if (beginIndex > index) {\n                arrPush.call(result, {\n                    type: 'literal',\n                    value: pattern.substring(index, beginIndex),\n                });\n            }\n            // d.\n            let p = pattern.substring(beginIndex + 1, endIndex);\n            // e.\n            if (dateTimeComponents.hasOwnProperty(p)) {\n              //   i. Let f be the value of the [[<p>]] internal property of dateTimeFormat.\n              let f = internal['[['+ p +']]'];\n              //  ii. Let v be the value of tm.[[<p>]].\n              let v = tm['[['+ p +']]'];\n              // iii. If p is \"year\" and v ≤ 0, then let v be 1 - v.\n              if (p === 'year' && v <= 0) {\n                v = 1 - v;\n              }\n              //  iv. If p is \"month\", then increase v by 1.\n              else if (p === 'month') {\n                v++;\n              }\n              //   v. If p is \"hour\" and the value of the [[hour12]] internal property of\n              //      dateTimeFormat is true, then\n              else if (p === 'hour' && internal['[[hour12]]'] === true) {\n                  // 1. Let v be v modulo 12.\n                  v = v % 12;\n                  // 2. If v is 0 and the value of the [[hourNo0]] internal property of\n                  //    dateTimeFormat is true, then let v be 12.\n                  if (v === 0 && internal['[[hourNo0]]'] === true) {\n                      v = 12;\n                  }\n              }\n\n              //  vi. If f is \"numeric\", then\n              if (f === 'numeric') {\n                  // 1. Let fv be the result of calling the FormatNumber abstract operation\n                  //    (defined in 11.3.2) with arguments nf and v.\n                  fv = FormatNumber(nf, v);\n              }\n              // vii. Else if f is \"2-digit\", then\n              else if (f === '2-digit') {\n                  // 1. Let fv be the result of calling the FormatNumber abstract operation\n                  //    with arguments nf2 and v.\n                  fv = FormatNumber(nf2, v);\n                  // 2. If the length of fv is greater than 2, let fv be the substring of fv\n                  //    containing the last two characters.\n                  if (fv.length > 2) {\n                      fv = fv.slice(-2);\n                  }\n              }\n              // viii. Else if f is \"narrow\", \"short\", or \"long\", then let fv be a String\n              //     value representing f in the desired form; the String value depends upon\n              //     the implementation and the effective locale and calendar of\n              //     dateTimeFormat. If p is \"month\", then the String value may also depend\n              //     on whether dateTimeFormat has a [[day]] internal property. If p is\n              //     \"timeZoneName\", then the String value may also depend on the value of\n              //     the [[inDST]] field of tm.\n              else if (f in dateWidths) {\n                switch (p) {\n                  case 'month':\n                    fv = resolveDateString(localeData, ca, 'months', f, tm['[['+ p +']]']);\n                    break;\n\n                  case 'weekday':\n                    try {\n                      fv = resolveDateString(localeData, ca, 'days', f, tm['[['+ p +']]']);\n                      // fv = resolveDateString(ca.days, f)[tm['[['+ p +']]']];\n                    } catch (e) {\n                      throw new Error('Could not find weekday data for locale '+locale);\n                    }\n                    break;\n\n                  case 'timeZoneName':\n                    fv = ''; // TODO\n                    break;\n\n                    // TODO: Era\n                  default:\n                    fv = tm['[['+ p +']]'];\n                }\n              }\n              // ix\n              arrPush.call(result, {\n                type: p,\n                value: fv,\n              });\n            // f.\n            } else if (p === 'ampm') {\n              // i.\n              let v = tm['[[hour]]'];\n              // ii./iii.\n              fv = resolveDateString(localeData, ca, 'dayPeriods', v > 11 ? 'pm' : 'am');\n              // iv.\n              arrPush.call(result, {\n                type: 'dayPeriod',\n                value: fv,\n              });\n            // g.\n            } else {\n              arrPush.call(result, {\n                type: 'literal',\n                value: pattern.substring(beginIndex, endIndex + 1),\n              });\n            }\n            // h.\n            index = endIndex + 1;\n            // i.\n            beginIndex = pattern.indexOf('{', index);\n        }\n        // 12.\n        if (endIndex < pattern.length - 1) {\n          arrPush.call(result, {\n            type: 'literal',\n            value: pattern.substr(endIndex),\n          });\n        }\n        // 13.\n        return result;\n}\n\n/**\n * When the FormatDateTime abstract operation is called with arguments dateTimeFormat\n * (which must be an object initialized as a DateTimeFormat) and x (which must be a Number\n * value), it returns a String value representing x (interpreted as a time value as\n * specified in ES5, 15.9.1.1) according to the effective locale and the formatting\n * options of dateTimeFormat.\n */\nexport function FormatDateTime(dateTimeFormat, x) {\n  let parts = CreateDateTimeParts(dateTimeFormat, x);\n  let result = '';\n\n  for (let part in parts) {\n      result += parts[part].value;\n  }\n  return result;\n}\n\nfunction FormatToPartsDateTime(dateTimeFormat, x) {\n  let parts = CreateDateTimeParts(dateTimeFormat, x);\n  let result = [];\n  for (let part in parts) {\n    result.push({\n      type: parts[part].type,\n      value: parts[part].value,\n    });\n  }\n  return result;\n}\n\n\n/**\n * When the ToLocalTime abstract operation is called with arguments date, calendar, and\n * timeZone, the following steps are taken:\n */\nfunction ToLocalTime(date, calendar, timeZone) {\n    // 1. Apply calendrical calculations on date for the given calendar and time zone to\n    //    produce weekday, era, year, month, day, hour, minute, second, and inDST values.\n    //    The calculations should use best available information about the specified\n    //    calendar and time zone. If the calendar is \"gregory\", then the calculations must\n    //    match the algorithms specified in ES5, 15.9.1, except that calculations are not\n    //    bound by the restrictions on the use of best available information on time zones\n    //    for local time zone adjustment and daylight saving time adjustment imposed by\n    //    ES5, 15.9.1.7 and 15.9.1.8.\n    // ###TODO###\n    let d = new Date(date),\n        m = 'get' + (timeZone || '');\n\n    // 2. Return a Record with fields [[weekday]], [[era]], [[year]], [[month]], [[day]],\n    //    [[hour]], [[minute]], [[second]], and [[inDST]], each with the corresponding\n    //    calculated value.\n    return new Record({\n        '[[weekday]]': d[m + 'Day'](),\n        '[[era]]'    : +(d[m + 'FullYear']() >= 0),\n        '[[year]]'   : d[m + 'FullYear'](),\n        '[[month]]'  : d[m + 'Month'](),\n        '[[day]]'    : d[m + 'Date'](),\n        '[[hour]]'   : d[m + 'Hours'](),\n        '[[minute]]' : d[m + 'Minutes'](),\n        '[[second]]' : d[m + 'Seconds'](),\n        '[[inDST]]'  : false, // ###TODO###\n    });\n}\n\n/**\n * The function returns a new object whose properties and attributes are set as if\n * constructed by an object literal assigning to each of the following properties the\n * value of the corresponding internal property of this DateTimeFormat object (see 12.4):\n * locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day,\n * hour, minute, second, and timeZoneName. Properties whose corresponding internal\n * properties are not present are not assigned.\n */\n/* 12.3.3 */defineProperty(Intl.DateTimeFormat.prototype, 'resolvedOptions', {\n    writable: true,\n    configurable: true,\n    value: function () {\n        let prop,\n            descs = new Record(),\n            props = [\n                'locale', 'calendar', 'numberingSystem', 'timeZone', 'hour12', 'weekday',\n                'era', 'year', 'month', 'day', 'hour', 'minute', 'second', 'timeZoneName',\n            ],\n            internal = this !== null && typeof this === 'object' && getInternalProperties(this);\n\n        // Satisfy test 12.3_b\n        if (!internal || !internal['[[initializedDateTimeFormat]]'])\n            throw new TypeError('`this` value for resolvedOptions() is not an initialized Intl.DateTimeFormat object.');\n\n        for (let i = 0, max = props.length; i < max; i++) {\n            if (hop.call(internal, prop = '[[' + props[i] + ']]'))\n                descs[props[i]] = { value: internal[prop], writable: true, configurable: true, enumerable: true };\n        }\n\n        return objCreate({}, descs);\n    },\n});\n","// Sect 13 Locale Sensitive Functions of the ECMAScript Language Specification\n// ===========================================================================\n\nimport {\n    FormatNumber,\n    NumberFormatConstructor,\n} from \"./11.numberformat.js\";\n\nimport {\n    ToDateTimeOptions,\n    DateTimeFormatConstructor,\n    FormatDateTime,\n} from \"./12.datetimeformat.js\";\n\nlet ls = Intl.__localeSensitiveProtos = {\n    Number: {},\n    Date:   {},\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.2.1 */ls.Number.toLocaleString = function () {\n    // Satisfy test 13.2.1_1\n    if (Object.prototype.toString.call(this) !== '[object Number]')\n        throw new TypeError('`this` value must be a number for Number.prototype.toLocaleString()');\n\n    // 1. Let x be this Number value (as defined in ES5, 15.7.4).\n    // 2. If locales is not provided, then let locales be undefined.\n    // 3. If options is not provided, then let options be undefined.\n    // 4. Let numberFormat be the result of creating a new object as if by the\n    //    expression new Intl.NumberFormat(locales, options) where\n    //    Intl.NumberFormat is the standard built-in constructor defined in 11.1.3.\n    // 5. Return the result of calling the FormatNumber abstract operation\n    //    (defined in 11.3.2) with arguments numberFormat and x.\n    return FormatNumber(new NumberFormatConstructor(arguments[0], arguments[1]), this);\n};\n\n/**\n * When the toLocaleString method is called with optional arguments locales and options,\n * the following steps are taken:\n */\n/* 13.3.1 */ls.Date.toLocaleString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleString()');\n\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n    let x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    // 3. If locales is not provided, then let locales be undefined.\n    let locales = arguments[0];\n\n    // 4. If options is not provided, then let options be undefined.\n    let options = arguments[1];\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"any\", and \"all\".\n    options = ToDateTimeOptions(options, 'any', 'all');\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n    let dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleDateString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.2 */ls.Date.toLocaleDateString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleDateString()');\n\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n    let x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    // 3. If locales is not provided, then let locales be undefined.\n    let locales = arguments[0],\n\n    // 4. If options is not provided, then let options be undefined.\n    options = arguments[1];\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"date\", and \"date\".\n    options = ToDateTimeOptions(options, 'date', 'date');\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n    let dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\n/**\n * When the toLocaleTimeString method is called with optional arguments locales and\n * options, the following steps are taken:\n */\n/* 13.3.3 */ls.Date.toLocaleTimeString = function () {\n    // Satisfy test 13.3.0_1\n    if (Object.prototype.toString.call(this) !== '[object Date]')\n        throw new TypeError('`this` value must be a Date instance for Date.prototype.toLocaleTimeString()');\n\n    // 1. Let x be this time value (as defined in ES5, 15.9.5).\n    let x = +this;\n\n    // 2. If x is NaN, then return \"Invalid Date\".\n    if (isNaN(x))\n        return 'Invalid Date';\n\n    // 3. If locales is not provided, then let locales be undefined.\n    let locales = arguments[0];\n\n    // 4. If options is not provided, then let options be undefined.\n    let options = arguments[1];\n\n    // 5. Let options be the result of calling the ToDateTimeOptions abstract\n    //    operation (defined in 12.1.1) with arguments options, \"time\", and \"time\".\n    options = ToDateTimeOptions(options, 'time', 'time');\n\n    // 6. Let dateTimeFormat be the result of creating a new object as if by the\n    //    expression new Intl.DateTimeFormat(locales, options) where\n    //    Intl.DateTimeFormat is the standard built-in constructor defined in 12.1.3.\n    let dateTimeFormat = new DateTimeFormatConstructor(locales, options);\n\n    // 7. Return the result of calling the FormatDateTime abstract operation (defined\n    //    in 12.3.2) with arguments dateTimeFormat and x.\n    return FormatDateTime(dateTimeFormat, x);\n};\n\nexport default ls;\n","/**\n * @license Copyright 2013 Andy Earnshaw, MIT License\n *\n * Implements the ECMAScript Internationalization API in ES5-compatible environments,\n * following the ECMA-402 specification as closely as possible\n *\n * ECMA-402: http://ecma-international.org/ecma-402/1.0/\n *\n * CLDR format locale data should be provided using IntlPolyfill.__addLocaleData().\n */\n\nimport {\n    defineProperty,\n    hop,\n    arrPush,\n    arrShift,\n    internals,\n} from \"./util.js\";\n\nimport {\n    IsStructurallyValidLanguageTag,\n    defaultLocale,\n    setDefaultLocale,\n} from \"./6.locales-currencies-tz.js\";\n\nimport {\n    Intl,\n} from \"./8.intl.js\";\n\nimport \"./11.numberformat.js\";\n\nimport \"./12.datetimeformat.js\";\n\nimport ls from \"./13.locale-sensitive-functions.js\";\n\ndefineProperty(Intl, '__applyLocaleSensitivePrototypes', {\n    writable: true,\n    configurable: true,\n    value: function () {\n        defineProperty(Number.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Number.toLocaleString });\n        // Need this here for IE 8, to avoid the _DontEnum_ bug\n        defineProperty(Date.prototype, 'toLocaleString', { writable: true, configurable: true, value: ls.Date.toLocaleString });\n\n        for (let k in ls.Date) {\n            if (hop.call(ls.Date, k))\n                defineProperty(Date.prototype, k, { writable: true, configurable: true, value: ls.Date[k] });\n        }\n    },\n});\n\n/**\n * Can't really ship a single script with data for hundreds of locales, so we provide\n * this __addLocaleData method as a means for the developer to add the data on an\n * as-needed basis\n */\ndefineProperty(Intl, '__addLocaleData', {\n    value: function (data) {\n        if (!IsStructurallyValidLanguageTag(data.locale))\n            throw new Error(\"Object passed doesn't identify itself with a valid language tag\");\n\n        addLocaleData(data, data.locale);\n    },\n});\n\nfunction addLocaleData (data, tag) {\n    // Both NumberFormat and DateTimeFormat require number data, so throw if it isn't present\n    if (!data.number)\n        throw new Error(\"Object passed doesn't contain locale data for Intl.NumberFormat\");\n\n    let locale,\n        locales = [ tag ],\n        parts   = tag.split('-');\n\n    // Create fallbacks for locale data with scripts, e.g. Latn, Hans, Vaii, etc\n    if (parts.length > 2 && parts[1].length === 4)\n        arrPush.call(locales, parts[0] + '-' + parts[2]);\n\n    while ((locale = arrShift.call(locales))) {\n        // Add to NumberFormat internal properties as per 11.2.3\n        arrPush.call(internals.NumberFormat['[[availableLocales]]'], locale);\n        internals.NumberFormat['[[localeData]]'][locale] = data.number;\n\n        // ...and DateTimeFormat internal properties as per 12.2.3\n        if (data.date) {\n            data.date.nu = data.number.nu;\n            arrPush.call(internals.DateTimeFormat['[[availableLocales]]'], locale);\n            internals.DateTimeFormat['[[localeData]]'][locale] = data.date;\n        }\n    }\n\n    // If this is the first set of locale data added, make it the default\n    if (defaultLocale === undefined)\n        setDefaultLocale(tag);\n}\n\nexport default Intl;\n","import IntlPolyfill from \"./core.js\";\n\n// hack to export the polyfill as global Intl if needed\nif (typeof Intl !== undefined) {\n    Intl = IntlPolyfill;\n    IntlPolyfill.__applyLocaleSensitivePrototypes();\n}\n\nexport default IntlPolyfill;\n"],"names":["Intl","IntlPolyfill"],"mappings":"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Q,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,KAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAAQ,IAAR,CAAL;AACA,EAAA,aAAK,CAAC,KAAD,EAA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"}